<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java八股文, 小苏的碎碎念">
    <meta name="description" content="欢迎来到我的小世界">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Java八股文 | 小苏的碎碎念</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>



   <style>
    body{
       background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">小苏的碎碎念</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">小苏的碎碎念</div>
        <div class="logo-desc">
            
            欢迎来到我的小世界
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java八股文</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%85%AB%E8%82%A1/">
                                <span class="chip bg-color">八股</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0/" class="post-category">
                                八股笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-04-14
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    40.2k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    147 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="1、-Java语言有哪些特点"><a href="#1、-Java语言有哪些特点" class="headerlink" title="1、 Java语言有哪些特点"></a>1、 Java语言有哪些特点</h2><p>1、简单易学、有丰富的类库</p>
<p>2、面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）</p>
<p>3、与平台无关性（JVM是Java跨平台使用的根本）</p>
<p>4、可靠安全</p>
<p>5、支持多线程</p>
<h2 id="2、面向对象和面向过程的区别"><a href="#2、面向对象和面向过程的区别" class="headerlink" title="2、面向对象和面向过程的区别"></a>2、面向对象和面向过程的区别</h2><p><strong>面向过程</strong>：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发</p>
<p><strong>面向对象</strong>：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有<strong>封装、继承、多态</strong>的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。<br>但是性能上来说，比面向过程要低。</p>
<h2 id="3-、八种基本数据类型的大小，以及他们的封装类"><a href="#3-、八种基本数据类型的大小，以及他们的封装类" class="headerlink" title="3 、八种基本数据类型的大小，以及他们的封装类"></a>3 、八种基本数据类型的大小，以及他们的封装类</h2><table>
<thead>
<tr>
<th>基本类型</th>
<th>大小（字节）</th>
<th>默认值</th>
<th>封装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
<td>(byte)0</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>(short)0</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>0</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>0L</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>0.0f</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>0.0d</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>-</td>
<td>false</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td><code>\u0000(null)</code></td>
<td>Character</td>
</tr>
</tbody></table>
<p>注：</p>
<ol>
<li><p>int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是<code>null</code>，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。</p>
</li>
<li><p>基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，<strong>必须通过实例化</strong>开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。</p>
</li>
</ol>
<p>虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。</p>
<p>这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的是32&#x2F;64位系统，而是指CPU硬件层面），具有高效存取的特点。</p>
<h2 id="4、标识符的命名规则。"><a href="#4、标识符的命名规则。" class="headerlink" title="4、标识符的命名规则。"></a>4、标识符的命名规则。</h2><p><strong>标识符的含义：</strong><br>是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。</p>
<blockquote>
<p><strong>命名规则：（硬性要求）</strong> 标识符可以包含英文字母，0-9的数字，$以及_<br>标识符不能以数字开头 标识符不是关键字</p>
</blockquote>
<p><strong>命名规范：（非硬性要求）</strong><br>类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。<br>变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。<br>方法名规范：同变量名。</p>
<h2 id="5、instanceof-关键字的作用"><a href="#5、instanceof-关键字的作用" class="headerlink" title="5、instanceof 关键字的作用"></a>5、instanceof 关键字的作用</h2><p><code>instanceof</code>严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> result <span class="token operator">=</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">Class</span>
</code></pre>
<p>其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class的对象，或者是<strong>其直接或间接子类，或者是其接口的实现类</strong>，结果result 都返回true，否则返回false。</p>
<p>注意：编译器会检查 obj是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token keyword">instanceof</span> <span class="token class-name">Integer</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//编译不通过 i必须是引用类型，不能是基本类型</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//编译不通过</span>

Integer integer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>integer <span class="token keyword">instanceof</span> <span class="token class-name">Integer</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>

<span class="token comment" spellcheck="true">//false ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回 false。</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>null <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="6、Java自动装箱与拆箱"><a href="#6、Java自动装箱与拆箱" class="headerlink" title="6、Java自动装箱与拆箱"></a>6、Java自动装箱与拆箱</h2><blockquote>
<p><strong>装箱就是自动将基本数据类型转换为包装器类型（int--&gt;Integer）；调用方法：Integer的</strong></p>
<p><strong>valueOf(int) 方法</strong></p>
<p><strong>拆箱就是自动将包装器类型转换为基本数据类型（Integer--&gt;int）。调用方法：Integer的</strong></p>
<p><strong>intValue方法</strong></p>
</blockquote>
<p>在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：</p>
<pre class=" language-java"><code class="language-java">Integer i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>而在从JavaSE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：</p>
<pre><code>Integer i = 10;
</code></pre>
<p><strong>面试题1： 以下代码会输出什么？</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Integer i1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    Integer i2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    Integer i3 <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    Integer i4 <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1<span class="token operator">==</span>i2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3<span class="token operator">==</span>i4<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>运行结果：true、false</p>
<p>为什么会出现这样的结果？输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token operator">-</span><span class="token number">128</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>
        <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>其中IntegerCache类的实现为：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> Integer cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// high value may be configured by property</span>
        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// Use Long.decode here to avoid invoking methods that</span>
            <span class="token comment" spellcheck="true">// require Integer's autoboxing cache to be initialized</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> Long<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// Maximum array size is Integer.MAX_VALUE</span>
            h <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token operator">-</span>low<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        high <span class="token operator">=</span> h<span class="token punctuation">;</span>
        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
            cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token function">IntegerCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p>
<p>上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。</p>
<p><strong>面试题2：以下代码输出什么</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Double i1 <span class="token operator">=</span> <span class="token number">100.0</span><span class="token punctuation">;</span>
        Double i2 <span class="token operator">=</span> <span class="token number">100.0</span><span class="token punctuation">;</span>
        Double i3 <span class="token operator">=</span> <span class="token number">200.0</span><span class="token punctuation">;</span>
        Double i4 <span class="token operator">=</span> <span class="token number">200.0</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1<span class="token operator">==</span>i2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3<span class="token operator">==</span>i4<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>运行结果：false false</p>
<p>原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p>
<h2 id="7、-重载和重写的区别"><a href="#7、-重载和重写的区别" class="headerlink" title="7、 重载和重写的区别"></a>7、 重载和重写的区别</h2><p>重写(Override)</p>
<p>从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下，对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>
        Son s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>重写 总结：</strong> 1.发生在父类与子类之间<br>2.方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同<br>3.访问修饰符的限制一定要大于被重写方法的访问修饰符</p>
<p>（public&gt;protected&gt;default&gt;private)<br>4.重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</p>
<p>重载（Overload）</p>
<blockquote>
<p>在一个类中，同名的方法如果有不同的参数列表（<strong>参数类型不同、参数个数不同甚至是参数顺序不同</strong>）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但<strong>不能通过返回类型是否相同来判断重载</strong>。</p>
</blockquote>
<p><strong>重载 总结：</strong> </p>
<p>1.重载Overload是一个类中多态性的一种表现<br>2.重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)<br>3.重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</p>
<h2 id="8、-equals与-的区别"><a href="#8、-equals与-的区别" class="headerlink" title="8、 equals与&#x3D;&#x3D;的区别"></a>8、 equals与&#x3D;&#x3D;的区别</h2><p><code>==</code> 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是 <strong>否是指相同一个对象</strong>。比较的是真正意义上的指针操作。 </p>
<p>1、比较的是操作符两端的操作数是否是<strong>同一个对象</strong>。 </p>
<p>2、两边的操作数必须是同一类型的（可以是 父子类之间）才能编译通过。 </p>
<p>3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为 true。</p>
<blockquote>
<p>如： int a&#x3D;10 与 long b&#x3D;10L 与 double c&#x3D;10.0都是相同的（为true）</p>
</blockquote>
<p><code>equals</code>用来比较的是两个对象的<strong>内容</strong>是否相等，由于所有的类都是继承自<code>java.lang.Object</code>类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object 中的equals方法<strong>返回的却是&#x3D;&#x3D;的判断</strong>。</p>
<p>自定义的类如果没重写<code>equals</code>方法，那用的时候调用的仍然是<code>==</code>，所以依然是比较的地址。</p>
<p>总结： 所有比较是否相等时，都是用<code>equals </code>并且在对常量相比较时，把常量写在前面，因为使用object的 <code>equals</code>，object可能为<code>null</code> 则空指针。在阿里的代码规范中只使用<code>equals </code>，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排查<code>==</code>替换成<code>equals</code></p>
<h2 id="9、-Hashcode的作用"><a href="#9、-Hashcode的作用" class="headerlink" title="9、 Hashcode的作用"></a>9、 Hashcode的作用</h2><p>java的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复。当我们在set 中插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法就会比较慢。</p>
<p>于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域。 </p>
<p><code>hashCode</code>方法可以这样理解：</p>
<p>它返回的就是根据<strong>对象的内存地址</strong>换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素（注意这个元素是一个对象，比如某个set的add方法，add一个Student对象）的<code>hashCode</code>方法（使用这个student对象的内存地址），就一下子能定位到它应该放置的物理位置上（计算的结果根据一定的规律映射到内存的物理地址上）。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p>
<blockquote>
<p><strong><code>hashCode</code>和<code>equals</code>的关系</strong>：</p>
<p>如果两个对象相等（即<code>equals</code>方法返回<code>true</code>），那么这两个对象的<code>hashCode</code>值必须相同。反之，如果<code>hashCode</code>值相同，对象不一定相等（因为不同的对象可能会有相同的<code>hashCode</code>值）。如果重写了<code>equals</code>方法，通常也需要重写<code>hashCode</code>方法，以确保满足上述关系。</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Student s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Map<span class="token operator">&lt;</span>Student<span class="token punctuation">,</span> Integer<span class="token operator">></span> scores <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        scores<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>scores<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//得到null</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>

     <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token annotation punctuation">@Override</span>
     <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         Student student <span class="token operator">=</span> <span class="token punctuation">(</span>Student<span class="token punctuation">)</span> o<span class="token punctuation">;</span>
         <span class="token keyword">return</span> age <span class="token operator">==</span> student<span class="token punctuation">.</span>age <span class="token operator">&amp;&amp;</span>
                 Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> student<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p>原因就在于重写 <code>equals()</code> 方法的时候没有重写 <code>hashCode()</code> 方法。默认情况下，<code>hashCode()</code> 方法是一个本地方法，会返回对象的存储地址，显然 <code>put()</code> 中的 s1 和 <code>get()</code> 中的 <code>new Student(18, &quot;张三&quot;)</code> 是两个对象，它们的存储地址肯定是不同的。</p>
<p>HashMap 的 <code>get()</code> 方法会调用 <code>hash(key.hashCode())</code> 计算对象的哈希值【原因所在】，虽然两个不同的 <code>hashCode()</code> 结果经过 <code>hash()</code> 方法计算后有可能得到相同的结果，但这种概率微乎其微，所以就导致 <code>scores.get(new Student(18, &quot;张三&quot;))</code> 无法得到预期的值 18。</p>
<p>解决方法 重写student的<code>hashcode()</code>方法</p>
</blockquote>
<h2 id="10、String、String-StringBuﬀer-和-StringBuilder-的区别是什么"><a href="#10、String、String-StringBuﬀer-和-StringBuilder-的区别是什么" class="headerlink" title="10、String、String StringBuﬀer 和 StringBuilder 的区别是什么?"></a>10、String、String StringBuﬀer 和 StringBuilder 的区别是什么?</h2><p>String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个<strong>ﬁnal类型的字符数组</strong>，所引用的字符串不能被改变，一经定义，无法再增删改。</p>
<p><strong>每次对String的操作都会生成新的String对象。</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
<p>每次+操作 ：<br>隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法拼接+后面的字符。</p>
<p>StringBuﬀer和StringBuilder他们两都继承了<code>AbstractStringBuilder</code>抽象类，从<br><code>AbstractStringBuilder</code>抽象类中我们可以看到</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 
* The value is used for character storage. 
*/</span> 
<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>
</code></pre>
<p>他们的底层都是可变的字符数组，所以在进行频繁的字符串操作时，建议使用<code>StringBuﬀer和 StringBuilder</code>来进行操作。 另外StringBuﬀer对方法加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。StringBuilder并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的。</p>
<h2 id="11、ArrayList和LinkedList的区别"><a href="#11、ArrayList和LinkedList的区别" class="headerlink" title="11、ArrayList和LinkedList的区别"></a>11、ArrayList和LinkedList的区别</h2><p>Array（数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。</p>
<p>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据(因为删除数据以后, 需要把后面所有的数据前移)</p>
<p><strong>缺点:</strong> 数组初始化必须指定初始化的长度, 否则报错例如:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//推介使用int[] 这种方式初始化</span>
<span class="token keyword">int</span> c<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">56</span><span class="token punctuation">,</span><span class="token number">78</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//长度：4，索引范围：[0,3]</span>
</code></pre>
<p>List是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。List有两个重要的实现类：<code>ArrayList和LinkedList</code></p>
<blockquote>
<p>ArrayList: 可以看作是能够自动增长容量的数组</p>
<p>ArrayList的 toArray方法返回一个数组 ArrayList的asList方法返回一个列表</p>
<p>ArrayList底层的实现是Array, 数组扩容实现</p>
<p>LinkList是一个双链表,在增删元素时具有比ArrayList更好的性能。但在get与set方面弱于ArrayList。</p>
</blockquote>
<h2 id="12、-HashMap和HashTable的区别"><a href="#12、-HashMap和HashTable的区别" class="headerlink" title="12、 HashMap和HashTable的区别"></a>12、 HashMap和HashTable的区别</h2><p>1、两者父类不同</p>
<p>HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。</p>
<p>2、对外提供的接口不同</p>
<p>Hashtable比HashMap多提供了elments() 和contains() 两个方法。</p>
<ul>
<li>elments()方法继承自Hashtable的父类Dictionnary。elements()方法用于返回此Hashtable中的value的枚举。</li>
<li>contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。</li>
</ul>
<p>事实上，contansValue()就只是调用了一下contains() 方法。</p>
<p>3、对null的支持不同</p>
<p>Hashtable：key和value都不能为null。</p>
<p>HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个<br>key值对应的value为null。</p>
<p>4、安全性不同</p>
<p>HashMap是<strong>线程不安全的</strong>，在多线程并发的环境下，可能会<strong>产生死锁等</strong>问题，因此需要开发人员自己处理多线程的安全问题。</p>
<p>Hashtable是线程安全的，它的每个方法上都有<strong>synchronized</strong>关键字，因此可直接用于多线程中。</p>
<p>虽然HashMap是线程不安全的，但是它的<strong>效率远远高于Hashtable</strong>，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的<code>ConcurrentHashMap</code>。</p>
<p><code>ConcurrentHashMap</code>虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为<br><code>ConcurrentHashMap</code>使用了分段锁，并不对整个数据进行锁定。</p>
<p>5、初始容量大小和每次扩充容量大小不同</p>
<p>6、计算hash值的方法不同</p>
<h2 id="13、-Collection包结构，与Collections的区别"><a href="#13、-Collection包结构，与Collections的区别" class="headerlink" title="13、 Collection包结构，与Collections的区别"></a>13、 Collection包结构，与Collections的区别</h2><p>Collection 接口有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有<code>ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap</code>等等。</p>
<p>Collections是集合类的一个帮助类，它包含有各种【有关集合操作的静态多态方法】，用于实现对各种集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个【工具类】，服务于Java的<br>Collection框架。</p>
<h2 id="14、-Java的四种引用，强弱软虚"><a href="#14、-Java的四种引用，强弱软虚" class="headerlink" title="14、 Java的四种引用，强弱软虚"></a>14、 Java的四种引用，强弱软虚</h2><ul>
<li><p>强引用</p>
<p>当一个对象被强引用变量引用时，它处于可达状态，垃圾回收器不会回收它。即便这个对象以后不会再被使用，只要强引用还存在，它所占用的内存就不会被释放，因此强引用可能导致内存泄漏问题。使用方式：</p>
<pre class=" language-java"><code class="language-java">String str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"str"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
<li><p>软引用</p>
<p>软引用通过<code>SoftReference</code>类实现。如果一个对象只被软引用指向，那么在系统内存足够的情况下，它不会被垃圾回收机制回收。但是，当JVM内存不足时，这些对象会被垃圾回收器回收，以避免内存溢出异常的发生。使用方式：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，</span>
<span class="token comment" spellcheck="true">// 这里的软引用指的是指向new String("str")的引用，也就是SoftReference类中T</span>
SoftReference<span class="token operator">&lt;</span>String<span class="token operator">></span> wrf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"str"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>可用场景：创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。</p>
</li>
<li><p>弱引用</p>
<p>弱引用通过<code>WeakReference</code>类实现，并且比软引用的生存期更短。无论JVM的内存是否充足，只要垃圾回收器运行，只有弱引用的对象就会被回收。使用方式：</p>
<pre class=" language-java"><code class="language-java">WeakReference<span class="token operator">&lt;</span>String<span class="token operator">></span> wrf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>可用场景：</strong> Java源码中的中的<code>java.util.WeakHashMap</code>中的key就是使用弱引用，理解为，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。</p>
</li>
<li><p>虚引用</p>
<p>虚引用也称为幽灵引用或幻影引用，通过<code>PhantomReference</code>类实现。虚引用是四种引用中最弱的一种，它对对象的生存时间没有任何影响。虚引用的主要目的是能够知道对象何时被垃圾收集器回收，并在适当的时候得到相关通知。它常常和引用队列一起使用来跟踪对象的垃圾回收状态。使用例子：</p>
<pre class=" language-java"><code class="language-java">PhantomReference<span class="token operator">&lt;</span>String<span class="token operator">></span> prf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"str"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>可用场景：<br>对象销毁前的一些操作，比如说资源释放等。<code>Object.finalize() </code>虽然也可以做这类动作，但是这个方式即不安全又低效</p>
</li>
</ul>
<p>上述所说的几类引用，都是指对象本身的引用，而不是指Reference的四个子类的引用</p>
<p>(SoftReference等)。</p>
<h2 id="15、-泛型常用特点"><a href="#15、-泛型常用特点" class="headerlink" title="15、 泛型常用特点"></a>15、 泛型常用特点</h2><blockquote>
<p>“泛型” 意味着编写的代码可以被不同类型的对象所重用。</p>
</blockquote>
<p>“泛型”，顾名思义，”泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的ArrayList就是个泛型类，ArrayList作为集合可以存放各种元素，如<br>Integer, String，自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，如我们可以约束集合中只存放Integer类型的元素，如</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> iniData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>使用泛型的好处？</p>
<p>以集合来举例，使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了Object即可，添加的数据全部都可向上转型为Object。更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。</p>
<h2 id="16、Java创建对象有几种方式？"><a href="#16、Java创建对象有几种方式？" class="headerlink" title="16、Java创建对象有几种方式？"></a>16、Java创建对象有几种方式？</h2><p>java中提供了以下四种创建对象的方式:</p>
<ul>
<li><p>new创建新对象</p>
<pre class=" language-java"><code class="language-java">Student stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
<li><p>通过反射机制</p>
<p>主要用于动态加载类，然后通过反射机制创建对象。</p>
<pre class=" language-java"><code class="language-java">Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.example.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Person person <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
<li><p>采用clone机制</p>
<p>通过实现<code>Cloneable</code>接口并重写<code>clone()</code>方法，可以创建一个对象的副本。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>
<span class="token comment" spellcheck="true">//属性、构造函数略</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>
        Person person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Person person2 <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> person1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><p>通过序列化机制</p>
<p>通过将对象的序列化形式（如JSON、XML等）转换为字节流，再将字节流反序列化为对象。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 序列化</span>
ByteArrayOutputStream baos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ObjectOutputStream oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>baos<span class="token punctuation">)</span><span class="token punctuation">;</span>
oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> baos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 反序列化</span>
ByteArrayInputStream bais <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
ObjectInputStream ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bais<span class="token punctuation">)</span><span class="token punctuation">;</span>
Person person <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</li>
</ul>
<h2 id="17、有没有可能两个不相等的对象有相同的hashcode"><a href="#17、有没有可能两个不相等的对象有相同的hashcode" class="headerlink" title="17、有没有可能两个不相等的对象有相同的hashcode"></a>17、有没有可能两个不相等的对象有相同的hashcode</h2><p>有可能。在产生hash冲突时,两个不相等的对象就会有相同的 hashcode值，当hash冲突产生时,一般有以下几种方式来处理:</p>
<ul>
<li><p>拉链法:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.</p>
</li>
<li><p>开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入</p>
</li>
<li><p>再哈希:又叫双哈希法,有多个不同的Hash函数。当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突</p>
</li>
</ul>
<h2 id="18、深拷贝和浅拷贝的区别是什么"><a href="#18、深拷贝和浅拷贝的区别是什么" class="headerlink" title="18、深拷贝和浅拷贝的区别是什么?"></a>18、深拷贝和浅拷贝的区别是什么?</h2><p>浅拷贝:被复制对象的所有变量都含有与原来的对象相同的值,而所有的【对其他对象的引用】仍然指向【原来的对象】.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象</p>
<p>深拷贝:被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把【要复制的对象所引用的对象都复制了一遍】</p>
<h2 id="19、ﬁnal有哪些用法"><a href="#19、ﬁnal有哪些用法" class="headerlink" title="19、ﬁnal有哪些用法?"></a>19、ﬁnal有哪些用法?</h2><ul>
<li><p>被ﬁnal修饰的类不可以被继承</p>
</li>
<li><p>被ﬁnal修饰的方法不可以被重写</p>
</li>
<li><p>被ﬁnal修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.</p>
</li>
<li><p>被ﬁnal修饰的方法,JVM会尝试将其内联,以提高运行效率</p>
</li>
<li><p>被ﬁnal修饰的常量,在编译阶段会存入常量池中</p>
</li>
</ul>
<p>除此之外,编译器对ﬁnal域要遵守的两个重排序规则，确保了 final 域的正确性和多线程安全性:</p>
<ul>
<li><p>在构造函数内对一个ﬁnal域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">FinalFieldExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
    <span class="token function">FinalFieldExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在构造函数内对final域进行写入操作</span>
        y <span class="token operator">=</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//根据重排序规则，编译器和处理器不能将这两个操作进行重排序，以确保 x 的初始化在其他线程可见之前完成。</span>
</code></pre>
</li>
<li><p>初次读一个包含ﬁnal域的对象的引用,与随后初次读这个ﬁnal域,这两个操作之间不能重排序</p>
<pre class=" language-java"><code class="language-java">FinalFieldExample obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FinalFieldExample</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建对象并初始化final域</span>
<span class="token keyword">int</span> value <span class="token operator">=</span> obj<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 第一次读取包含final域的对象的引用</span>
<span class="token keyword">int</span> anotherValue <span class="token operator">=</span> obj<span class="token punctuation">.</span>y<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 第一次读取final域(???)</span>
<span class="token comment" spellcheck="true">//根据重排序规则，编译器和处理器不能将这两个读取操作进行重排序，以确保在读取 x 的值之前，x 的初始化已经完成。</span>
</code></pre>
</li>
</ul>
<h2 id="20、static都有哪些用法"><a href="#20、static都有哪些用法" class="headerlink" title="20、static都有哪些用法?"></a>20、static都有哪些用法?</h2><p>所有的人都知道static关键字这两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量&#x2F;方法都属于类的静态资源,类实例所共享</p>
<p>除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> calss PreCache<span class="token punctuation">{</span>
    <span class="token keyword">static</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//执行相关操作</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<ul>
<li>在类的加载过程中只执行一次，通常用于初始化静态变量或执行只需要进行一次的设置。适用于那些只需要执行一次的操作，如创建连接池、读取配置文件等。</li>
<li>静态代码块的执行优先级高于非静态的初始化块和构造函数。在类加载时，首先执行静态代码块，然后是非静态的初始化块，最后是构造函数。</li>
<li>静态代码块中的内容存在于方法区（也称为静态区），可以被所有线程共享。这意味着在多线程环境下，静态代码块中的资源和数据是共享的。</li>
</ul>
<p>此外static也多用于修饰内部类,此时称之为静态内部类.</p>
<p>最后一种用法就是静态导包,在JDK1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> <span class="token keyword">static</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Math<span class="token punctuation">.</span>*<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//System.out.println(Math.sin(20));传统做法</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="21、3-0-1-0-3返回值是什么"><a href="#21、3-0-1-0-3返回值是什么" class="headerlink" title="21、3*0.1&#x3D;&#x3D;0.3返回值是什么"></a>21、3*0.1&#x3D;&#x3D;0.3返回值是什么</h2><p>false,因为有些浮点数不能完全精确的表示出来</p>
<h2 id="22、a-a-b与a-b有什么区别吗"><a href="#22、a-a-b与a-b有什么区别吗" class="headerlink" title="22、a&#x3D;a+b与a+&#x3D;b有什么区别吗?"></a>22、a&#x3D;a+b与a+&#x3D;b有什么区别吗?</h2><p><code>+=</code>操作符会进行隐式自动类型转换,此处<code>a+=b</code>隐式的将加操作的结果类型强制转换为持有结果的类型,而<code>a=a+b</code>则不会自动进行类型转换。如：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">byte</span> a <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
<span class="token keyword">byte</span> b <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 报编译错误:cannot convert from int to byte</span>
b <span class="token operator">+=</span> a<span class="token punctuation">;</span>

<span class="token keyword">short</span> s1<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
s1 <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//有错误.short类型在进行运算时会自动提升为int类型,也就是说s1+1 的运算结果是int类型,而s1是short类型,此时编译器会报错.</span>
<span class="token comment" spellcheck="true">//正确写法</span>
<span class="token keyword">short</span> s1<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
s1 <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="23、try-catch-ﬁnally，try里有return，ﬁnally还执行么？"><a href="#23、try-catch-ﬁnally，try里有return，ﬁnally还执行么？" class="headerlink" title="23、try catch ﬁnally，try里有return，ﬁnally还执行么？"></a>23、try catch ﬁnally，try里有return，ﬁnally还执行么？</h2><p>执行，并且ﬁnally的执行早于try里面的return</p>
<p>结论：</p>
<p>1、不管有木有出现异常，ﬁnally块中代码都会执行；</p>
<p>2、当try和catch中有return时，ﬁnally仍然会执行；</p>
<p>3、ﬁnally是在return【后面的表达式运算后执行的】（此时并没有返回运算后的值，而是先把要返回的值保存起来，<strong>不管ﬁnally中的代码怎么样，返回的值都不会改变</strong>，任然是之前保存的值），所以<strong>函数返回值是在ﬁnally执行前确定的</strong>；</p>
<p>4、ﬁnally中最好不要包含return，否则程序会提前退出。</p>
<h2 id="24、-Excption与Error包结构"><a href="#24、-Excption与Error包结构" class="headerlink" title="24、 Excption与Error包结构"></a>24、 Excption与Error包结构</h2><p>Java可抛出(<code>Throwable</code>)的结构分为三种类型：被检查的异常(<code>CheckedException</code>)，运行时异常<br>(<code>RuntimeException</code>)，错误(<code>Error</code>)。</p>
<p>1、运行时异常</p>
<p>定义:<code>RuntimeException</code>及其子类都被称为运行时异常。</p>
<p>特点:Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既&quot;没有通过throws声明抛出它&quot;，也&quot;没有用try-catch语句捕获它&quot;，还是会编译通过。例如，除数为零时产生的<code>ArithmeticException</code>异常，数组越界时产生的<code>IndexOutOfBoundsException</code>异常，fail-fast机制产生的<code>ConcurrentModiﬁcationException</code>异常等，都属于运行时异常。常见的五种运行时异常：</p>
<p>ClassCastException（类转换异常） </p>
<p>IndexOutOfBoundsException（数组越界）</p>
<p>NullPointerException（空指针异常）</p>
<p>ArrayStoreException（数据存储异常，操作数组是类型不一致）</p>
<p>BuﬀerOverﬂowException</p>
<p>2、被检查异常</p>
<p>定义:Exception类本身，以及Exception的子类中除了&quot;运行时异常&quot;之外的<strong>其它子类都属于被检查异常</strong>。</p>
<p>特点 : <strong>Java编译器会检查它。</strong></p>
<p>此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。被检查异常通常都是可以恢复的。 如：</p>
<p>IOException </p>
<p>FileNotFoundException </p>
<p>SQLException</p>
<p>被检查的异常适用于那些不是因程序引起的错误情况，比如：读取文件时文件不存在引发的FileNotFoundException </p>
<p>3、错误</p>
<p>定义 : Error类及其子类。</p>
<p>特点 : 和运行时异常一样，编译器也不会对错误进行检查。</p>
<p>当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。出现这种错误会导致程序终止运行。</p>
<h2 id="25、OOM你遇到过哪些情况，SOF你遇到过哪些情况"><a href="#25、OOM你遇到过哪些情况，SOF你遇到过哪些情况" class="headerlink" title="25、OOM你遇到过哪些情况，SOF你遇到过哪些情况"></a>25、OOM你遇到过哪些情况，SOF你遇到过哪些情况</h2><p><strong>OOM</strong>：</p>
<p>1，OutOfMemoryError异常</p>
<p>除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生<code>OutOfMemoryError(OOM)</code>异常的可能。</p>
<p>Java Heap 溢出：</p>
<p>一般的异常信息：<code>java.lang.OutOfMemoryError:Java heap spacess</code>。</p>
<p>java堆用于存储对象实例，我们只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。</p>
<p>出现这种异常，一般手段是先通过内存映像分析工具(如<code>Eclipse Memory Analyzer</code>)对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是必要的，先分清是因为内存泄漏(<code>Memory Leak</code>)还是内存溢出(<code>Memory Overﬂow</code>)。</p>
<p>如果是内存泄漏，可进一步通过工具查看泄漏对象到<code>GCRoots</code>的引用链。于是就能找到泄漏对象是通过怎样的路径与<code>GC Roots</code>相关联并导致垃圾收集器无法自动回收。</p>
<p>如果不存在泄漏，那就应该检查虚拟机的参数(<code>-Xmx与-Xms</code>)的设置是否适当。</p>
<p>2，虚拟机栈和本地方法栈溢出</p>
<p>如果线程请求的<strong>栈深度</strong>大于虚拟机所允许的最大深度，将抛出<code>StackOverﬂowError</code>异常。如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</p>
<p>这里需要注意当栈的大小越大可分配的线程数就越少。</p>
<p>3，运行时常量池溢出</p>
<p>异常信息：<code>java.lang.OutOfMemoryError:PermGenspace</code></p>
<p>如果要向运行时常量池中添加内容，最简单的做法就是使用<code>String.intern()</code>这个Native方法。该方法的作用是：如果池中已经包含一个等于此String的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于【常量池分配在方法区内】，我们可以通过<code>-XX:PermSize和-XX:MaxPermSize</code>限制方法区的大小，从而间接限制其中常量池的容量。</p>
<p>4，方法区溢出</p>
<p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能是方法区中保存的class对象没有被及时回收掉或者class信息占用的内存超过了我们配置。</p>
<p>异常信息：<code>java.lang.OutOfMemoryError:PermGenspace</code></p>
<p>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，判定条件是很苛刻的。<strong>在经常动态生成大量Class的应用中</strong>，要特别注意这点。</p>
<p>SOF（堆栈溢出StackOverﬂow）：</p>
<p><code>StackOverﬂowError</code>的定义：当应用程序递归太深而发生堆栈溢出时，抛出该错误。</p>
<p>因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过1m而导致溢出。</p>
<p>栈溢出的原因：递归调用，大量循环或死循环，全局变量是否过多，数组、List、map数据过大。</p>
<h2 id="26、-简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#26、-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="26、 简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>26、 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程<strong>共享同一块内存空间和一组系统资源</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是<strong>静态的代码</strong>。</p>
<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>
<p><strong>协程</strong>是一种<strong>轻量级的线程，它可以由程序员在用户空间进行控制和调度</strong>。它允许在一个线程中的多个函数之间进行【协作式】的执行，而不是像传统的函数调用那样一味地按照调用顺序执行。协程相比于线程，有以下特点：</p>
<ol>
<li><strong>轻量化</strong>：协程比线程更轻量，创建和切换的开销远小于线程，可以创建数十万甚至数百万个协程。</li>
<li><strong>控制转移</strong>：协程提供了一种机制，使得程序的控制流可以在任意位置在一系列协程之间转移，而这种转移由程序员控制。</li>
<li><strong>异步编程</strong>：协程非常适合于异步编程模型，它们可以使代码编写起来更像是同步代码，而实际上却是高度并发的。</li>
<li><strong>语言支持</strong>：一些编程语言如Lua、Python和Go等，从语言层面提供了对协程的支持，使得使用协程变得更加方便。</li>
</ol>
<p>值得一提的是，在操作系统中，协程通常不是由操作系统内核管理，而是由程序库或运行环境提供。这意味着【协程的创建、销毁、调度等操作都是在用户空间】完成的，而不是在内核空间，这样可以大幅减少上下文切换的开销。</p>
<p>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为【同一进程中的线程极有可能会相互影响】。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>
<h2 id="27、Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#27、Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="27、Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>27、Java 序列化中如果有些字段不想进行序列化，怎么办？</h2><p><strong>Java序列化是一种机制，它允许将对象的状态转换为字节流，以便可以将其保存到文件或数据库中，或者通过网络发送到另一个运行Java的计算机上</strong>。</p>
<p>序列化主要通过实现<code>Serializable</code>接口来完成，这个接口是一个标记接口，不包含任何方法，它的作用是告诉Java虚拟机(JVM)这个类的对象是可以被序列化的。</p>
<p>当一个对象实现了<code>Serializable</code>接口后，就可以通过<code>ObjectOutputStream</code>类来将其写入到一个输出流中，这个过程就是序列化。相反，如果需要从输入流中读取数据并重新构建对象，就需要使用<code>ObjectInputStream</code>类，这个过程称为反序列化。【见第16相关代码】</p>
<p>序列化的主要用途是在传递和保存对象时，确保对象的完整性和可传递性。它的核心作用是保存对象状态，使其可以在不同环境或时间点被重建。在分布式环境下，尤其是在进行远程通信时，无论是何种类型的数据，都会以二进制序列的形式在网络上传送。序列化可以将对象的状态写入流中进行网络传输，或者保存到文件、数据库等系统中，并在需要时把该流读取出来重新构造一个相同的对象。</p>
<p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<p>作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被<br>transient 修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。</p>
<h2 id="28、说说Java-中-IO-流"><a href="#28、说说Java-中-IO-流" class="headerlink" title="28、说说Java 中 IO 流"></a>28、说说Java 中 IO 流</h2><p>Java 中 IO 流分为几种?</p>
<ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；字节流可以处理一切文件，而字符流只能处理纯文本文件。</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>按照 IO 的操作对象来思考，IO 就可以分类为：文件(可以细分为字节流（FileInput&#x2F;OuputStream）和字符流（FileReader&#x2F;Writer）)、数组（ByteArrayInputStream）、管道、基本数据类型、缓冲、打印、对象序列化&#x2F;反序列化，以及转换等。</p>
<p>相关的类分别是“XXInputStream和XXOutputStream”</p>
<p><img src="/assets/IO%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F.png"></p>
<p>字节流</p>
<p>顶层抽象父类: InputStream和OutputStream。根据交互的设备不同,操作内容不同, 顶层父类提供不同具体的子类。比如：</p>
<p>FileInputStream 文件字节输入流 FileOutputStream 文件字节输出流</p>
<p>ObjectInputStream 对象字节输入流 ObjectOutputStream 对象字节输出流</p>
<p>字符流</p>
<p>抽象顶层父类们: Reader 和 Writer</p>
<p>字节流本身没有缓冲区，<strong>缓冲字节流</strong><code>BufferedInpuStream和BufferedOutputStream</code>相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。</p>
<p><img src="/assets/IO%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F.png"></p>
<p>转换流，字节流和字符流之间的桥梁</p>
<p>编码表</p>
<p>GBK: 国标码, 定义时英文字符和中文字符, 在GBK编码表中,【一个英文使用一个字节】存储,【一个汉字两个字节】存储;</p>
<p>UTF-8: 万国码, 定义了全球所有的语言的符号, 定义了符号和数字的关系, 英文字符占一个字节, 【一个汉字占3个】字节;</p>
<p>转换流</p>
<ol>
<li>转换流一共有两个:<code>InputStreamReader 和 OutputStreamWriter</code></li>
<li><code>InputStreamReader</code>:是字节流转向字符流的桥梁,可以指定转换时使用字符集。是Reader子类, 可以用Reader类中定义的方法</li>
<li><code>OutputStreamWriter</code>:是<strong>字符流转向字节流</strong>的桥梁, 可以执行转换时的字符集。是Writer的子类, 就可以调用Writer类中定义的方法</li>
</ol>
<p>Java IO流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。<br>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。<br>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
<p><img src="/assets/image7.jpeg">{width&#x3D;”6.813979658792651in”<br>height&#x3D;”5.071353893263342in”}</p>
<h2 id="29、-Java-IO与-NIO的区别（补充）"><a href="#29、-Java-IO与-NIO的区别（补充）" class="headerlink" title="29、 Java IO与 NIO的区别（补充）"></a>29、 Java IO与 NIO的区别（补充）</h2><p>NIO即NewIO，这个库是在JDK1.4中才引入的。NIO和IO有相同的作用和目的，但实现方式不同，NIO主要用到的是块，所以NIO的效率要比IO高很多。在JavaAPI中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<h2 id="30、java反射的作用与原理"><a href="#30、java反射的作用与原理" class="headerlink" title="30、java反射的作用与原理"></a>30、java反射的作用与原理</h2><p>1、定义：</p>
<p>反射机制是在运行时，对于【任意一个类】，都能够知道这个类的【所有】属性和方法；对于任意一个对象，都能够调用它的【任意一个方法】。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p>
<blockquote>
<p><strong>这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。</strong></p>
</blockquote>
<p>2、哪里会用到反射机制？ jdbc就是典型的反射</p>
<pre class=" language-java"><code class="language-java">Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">'com.mysql.jdbc.Driver.class'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加载MySQL的驱动类</span>
</code></pre>
<p>这就是反射。如hibernate，struts等框架使用反射实现的。</p>
<p>3、反射的实现方式：</p>
<p>第一步：获取Class对象，有4中方法： </p>
<p>1）<code>Class.forName(&quot;类的路径&quot;)</code></p>
<p>2）<code>类名.class </code></p>
<p>3）<code>对象名.getClass()</code></p>
<p>4）基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象</p>
<p>4、通过类对象可以获取这个类中的所有内容。</p>
<p>构造方法, 成员方法, 属性, 内部类, 类的注解, 类所在包, 类的修饰符, 还可以通过类对象判断一个类类型。</p>
<p>1）Class：表示正在运行的Java应用程序中的类和接口 注意：所有获取对象的信息都需要Class类来实现。<br>2）Field：提供有关类和接口的属性信息，以及对它的动态访问权限。</p>
<p>3）Constructor：提供关于类的单个构造方法的信息以及它的访问权限</p>
<p>4）Method：提供类或接口中某个方法的信息</p>
<p>5、反射机制的优缺点：</p>
<p><strong>优点：</strong> 1）能够运行时动态获取类的实例，提高灵活性； 2）与动态编译结合<br><strong>缺点：</strong> </p>
<p>1）使用反射性能较低，需要解析字节码，将内存中的对象进行解析。</p>
<p>解决方案： </p>
<ul>
<li>通过<code>setAccessible(true)</code>关闭JDK的安全检查来提升反射速度；</li>
<li>多次创建一个类的实例时，有缓存会快很多 </li>
<li><code>ReﬂectASM</code>工具类，通过字节码生成的方式加快反射速度</li>
</ul>
<p>2）相对不安全，破坏了封装性（因为通过反射可以获得私有方法和属性）</p>
<h2 id="31、说说List-Set-Map三者的区别？"><a href="#31、说说List-Set-Map三者的区别？" class="headerlink" title="31、说说List,Set,Map三者的区别？"></a>31、说说List,Set,Map三者的区别？</h2><blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} <strong>List(对付顺序的好帮手)：</strong><br>List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} <strong>Set(注重独一无二的性质):</strong><br>不允许重复的集合。不会有多个元素引用相同的对象。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} <strong>Map(用Key来搜索的专家):</strong><br>使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</p>
</blockquote>
<h2 id="32-、Object-有哪些常用方法？大致说一下每个方法的含义"><a href="#32-、Object-有哪些常用方法？大致说一下每个方法的含义" class="headerlink" title="32.、Object 有哪些常用方法？大致说一下每个方法的含义"></a>32.、Object 有哪些常用方法？大致说一下每个方法的含义</h2><p>java.lang.Object</p>
<blockquote>
<p><img src="/assets/image8.png">{width&#x3D;”2.9791666666666665in”<br>height&#x3D;”3.1145833333333335in”}</p>
</blockquote>
<p>下面是对应方法的含义。</p>
<h4 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone 方法"></a>clone 方法</h4><p>保护方法，实现对象的浅复制，只有实现了 Cloneable<br>接口才可以调用该方法，否则抛出 CloneNotSupportedException<br>异常，深拷贝也需要实现 Cloneable，同时其成员变量为引用类型的也需要实现<br>Cloneable，然后重写 clone 方法。</p>
<h4 id="ﬁnalize-方法"><a href="#ﬁnalize-方法" class="headerlink" title="ﬁnalize 方法"></a>ﬁnalize 方法</h4><p>该方法和垃圾收集器有关系，判断一个对象是否可以被回收的最后一步就是判断是否重写了此方法。</p>
<h4 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals 方法"></a>equals 方法</h4><p>该方法使用频率非常高。一般 equals 和 &#x3D;&#x3D; 是不一样的，但是在 Object<br>中两者是一样的。子类一般都要重写这个方法。</p>
<h4 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode 方法"></a>hashCode 方法</h4><p>该方法用于哈希查找，重写了 equals 方法一般都要重写 hashCode<br>方法，这个方法在一些具有哈希功能的 Collection 中用到。</p>
<p>一般必须满足</p>
<p>。可以推出</p>
<blockquote>
<p>，但是</p>
</blockquote>
<p>hashCode 相等不一定就满足<br>equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} JDK 1.6、1.7 默认是返回随机数；</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} JDK 1.8<br>默认是通过和当前线程有关的一个随机数 + 三个确定值，运用 Marsaglia’s<br>xorshift scheme 随机数算法得到的一个随机数。</p>
</blockquote>
<h4 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait 方法"></a>wait 方法</h4><p>配合 synchronized 使用，wait<br>方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()<br>方法一直等待，直到获得锁或者被中断。wait(long<br>timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p>
<p>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p>
<ol>
<li><p>其他线程调用了该对象的 notify 方法；</p>
</li>
<li><p>其他线程调用了该对象的 notifyAll 方法；</p>
</li>
<li><p>其他线程调用了 interrupt 中断该线程；</p>
</li>
<li><p>时间间隔到了。</p>
</li>
</ol>
<p>此时该线程就可以被调度了，如果是被中断的话就抛出一个<br>InterruptedException 异常。</p>
<h4 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify 方法"></a>notify 方法</h4><p>配合 synchronized<br>使用，该方法唤醒在该对象上<strong>等待队列</strong>中的某个线程（同步队列中的线程是给抢占<br>CPU 的线程，等待队列中的线程指的是等待唤醒的线程）。</p>
<h4 id="notifyAll-方法"><a href="#notifyAll-方法" class="headerlink" title="notifyAll 方法"></a>notifyAll 方法</h4><p>配合 synchronized<br>使用，该方法唤醒在该对象上等待队列中的所有线程。<strong>总结</strong></p>
<p>只要把上面几个方法熟悉就可以了，toString 和 getClass<br>方法可以不用去讨论它们。该题目考察的是对 Object<br>的熟悉程度，平时用的很多方法并没看其定义但是也在用，比如说：wait()<br>方法， equals() 方法等。</p>
<p>大致意思：Object 是所有类的根，是所有类的父类，所有对象包括数组都实现了<br>Object 的方法。</p>
<h2 id="33、Java-创建对象有几种方式？"><a href="#33、Java-创建对象有几种方式？" class="headerlink" title="33、Java 创建对象有几种方式？"></a>33、Java 创建对象有几种方式？</h2><p>这题目看似简单，要好好回答起来还是有点小复杂的，我们来看看，到底有哪些方式可以创建对象？</p>
<blockquote>
<p><strong>使用 new 关键字</strong>，这也是我们平时使用的最多的创建对象的方式，示例：</p>
</blockquote>
<p><strong>使用反射方式创建对象</strong>，使用 newInstance()，但是得处理两个异常<br>InstantiationException、 IllegalAccessException：</p>
<blockquote>
<p><strong>使用 clone 方法</strong>，前面题目中 clone 是 Object<br>的方法，所以所有对象都有这个方法。<strong>使用反序列化创建对象</strong>，调用<br>ObjectInputStream 类的 readObject() 方法。</p>
</blockquote>
<p>我们反序列化一个对象，JVM 会给我们创建一个单独的对象。JVM<br>创建对象并不会调用任何构造函数。一个对象实现了 Serializable<br>接口，就可以把对象写入到文件中，并通过读取文件来创建对 象。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>创建对象的方式关键字：new、反射、clone 拷贝、反序列化。</p>
<h2 id="34、获取一个类Class对象的方式有哪些？"><a href="#34、获取一个类Class对象的方式有哪些？" class="headerlink" title="34、获取一个类Class对象的方式有哪些？"></a>34、获取一个类Class对象的方式有哪些？</h2><p>搞清楚类对象和实例对象，但都是对象。</p>
<p>第一种：通过类对象的 getClass() 方法获取，细心点的都知道，这个 getClass<br>是 Object 类里面的方法。</p>
<p>第二种：通过类的静态成员表示，每个类都有隐含的静态成员 class。</p>
<p>第三种：通过 Class 类的静态方法 forName() 方法获取。</p>
<h2 id="35、ArrayList-和-LinkedList-的区别有哪些？"><a href="#35、ArrayList-和-LinkedList-的区别有哪些？" class="headerlink" title="35、ArrayList 和 LinkedList 的区别有哪些？"></a>35、ArrayList 和 LinkedList 的区别有哪些？</h2><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} <strong>优点</strong>：ArrayList<br>是实现了基于动态数组的数据结构，因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} <strong>缺点</strong>：因为地址连续，ArrayList<br>要移动数据，所以插入和删除操作效率比较低。</p>
</blockquote>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} <strong>优点</strong>：LinkedList<br>基于链表的数据结构，地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址。对于新增和删除操作，LinkedList<br>比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} <strong>缺点</strong>：因为 LinkedList<br>要移动指针，所以查询操作性能比较低。<strong>适用场景分析</strong></p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>当需要对数据进行对随机访问的时候，选用 ArrayList。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>当需要对数据进行多次增加删除修改时，采用 LinkedList。</p>
</blockquote>
<p>如果容量固定，并且只会添加到尾部，不会引起扩容，优先采用 ArrayList。</p>
<p>当然，绝大数业务的场景下，使用 ArrayList 就够了，但需要注意避免<br>ArrayList 的扩容，以及非顺序的插入。</p>
<h2 id="36、用过-ArrayList-吗？说一下它有什么特点？"><a href="#36、用过-ArrayList-吗？说一下它有什么特点？" class="headerlink" title="36、用过 ArrayList 吗？说一下它有什么特点？"></a>36、用过 ArrayList 吗？说一下它有什么特点？</h2><p>只要是搞 Java<br>的肯定都会回答”用过”。所以，回答题目的后半部分——ArrayList<br>的特点。可以从这几个方面去回答：</p>
<p>Java<br>集合框架中的一种存放相同类型的元素数据，是一种变长的集合类，基于定长数组实现，当加入数据达到一定程度后，会实行自动扩容，即扩大数组大小。</p>
<p>底层是使用数组实现，添加元素。</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 如果<br>add(o)，添加到的是数组的尾部，如果要增加的数据量很大，应该使用<br>ensureCapacity()</p>
<p>方法，该方法的作用是预先设置 ArrayList<br>的大小，这样可以大大提高初始化速度。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 如果使用<br>add(int,o)，添加到某个位置，那么可能会挪动大量的数组元素，并且可能会触发扩容机制。</p>
</blockquote>
<p>高并发的情况下，线程不安全。多个线程同时操作<br>ArrayList，会引发不可预知的异常或错误。</p>
<p>ArrayList 实现了 Cloneable 接口，标识着它可以被复制。注意：ArrayList<br>里面的 clone() 复制其实是浅复制。</p>
<h2 id="37、有数组了为什么还要搞个-ArrayList-呢？"><a href="#37、有数组了为什么还要搞个-ArrayList-呢？" class="headerlink" title="37、有数组了为什么还要搞个 ArrayList 呢？"></a>37、有数组了为什么还要搞个 ArrayList 呢？</h2><p>通常我们在使用的时候，如果在不明确要插入多少数据的情况下，普通数组就很尴尬了，因为你不知道需要初始化数组大小为多少，而<br>ArrayList 可以使用默认的大小，当元素个数到达一定程度</p>
<p>后，会自动扩容。</p>
<p>可以这么来理解：我们常说的数组是定死的数组，ArrayList 却是动态数组。</p>
<h2 id="38、说说什么是-fail-fast？"><a href="#38、说说什么是-fail-fast？" class="headerlink" title="38、说说什么是 fail-fast？"></a>38、说说什么是 fail-fast？</h2><p>fail-fast 机制是 Java<br>集合（Collection）中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生<br>fail-fast 事件。</p>
<p>例如：当某一个线程 A 通过 iterator<br>去遍历某集合的过程中，若该集合的内容被其他线程所改变 了，那么线程 A<br>访问集合时，就会抛出 ConcurrentModiﬁcationException 异常，产生 fail-fast<br>事件。这里的操作主要是指 add、remove 和 clear，对集合元素个数进行修改。</p>
<p>解决办法：建议使用”java.util.concurrent 包下的类”去取代”java.util<br>包下的类”。</p>
<p>可以这么理解：在遍历之前，把 modCount 记下来 expectModCount，后面<br>expectModCount 去和 modCount<br>进行比较，如果不相等了，证明已并发了，被修改了，于是抛出<br>ConcurrentModiﬁcationException 异常。</p>
<h2 id="39、说说Hashtable-与-HashMap-的区别"><a href="#39、说说Hashtable-与-HashMap-的区别" class="headerlink" title="39、说说Hashtable 与 HashMap 的区别"></a>39、说说Hashtable 与 HashMap 的区别</h2><p>本来不想这么写标题的，但是无奈，面试官都喜欢这么问 HashMap。</p>
<ol>
<li>出生的版本不一样，Hashtable 出生于 Java 发布的第一版本 JDK<br>1.0，HashMap 出生于 JDK</li>
</ol>
<blockquote>
<p>1.2。</p>
</blockquote>
<ol start="2">
<li><p>都实现了 Map、Cloneable、Serializable（当前 JDK 版本 1.8）。</p>
</li>
<li><p>HashMap 继承的是 AbstractMap，并且 AbstractMap 也实现了 Map<br>接口。Hashtable 继承</p>
</li>
</ol>
<blockquote>
<p>Dictionary。</p>
</blockquote>
<ol start="4">
<li>Hashtable 中大部分 public 修饰普通方法都是 synchronized<br>字段修饰的，是线程安全的，</li>
</ol>
<blockquote>
<p>HashMap 是非线程安全的。</p>
</blockquote>
<ol start="5">
<li><p>Hashtable 的 key 不能为 null，value 也不能为 null，这个可以从<br>Hashtable 源码中的 put 方法看到，判断如果 value 为 null<br>就直接抛出空指针异常，在 put 方法中计算 key 的 hash 值之前并没有判断<br>key 为 null 的情况，那说明，这时候如果 key<br>为空，照样会抛出空指针异常。</p>
</li>
<li><p>HashMap 的 key 和 value 都可以为 null。在计算 hash<br>值的时候，有判断，如果</p>
</li>
</ol>
<p>，则其 ；至于 value 是否为 null，根本没有判断过。</p>
<ol start="7">
<li><p>Hashtable 直接使用对象的 hash 值。hash 值是 JDK<br>根据对象的地址或者字符串或者数字算出来的 int<br>类型的数值。然后再使用除留余数法来获得最终的位置。然而除法运算是非常耗费时间的，效率很低。HashMap<br>为了提高计算效率，将哈希表的大小固定为了 2<br>的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。</p>
</li>
<li><p>Hashtable、HashMap 都使用了 Iterator。而由于历史原因，Hashtable<br>还使用了</p>
</li>
</ol>
<blockquote>
<p>Enumeration 的方式。</p>
</blockquote>
<ol start="9">
<li>默认情况下，初始容量不同，Hashtable 的初始长度是<br>11，之后每次扩充容量变为之前的</li>
</ol>
<p>2n+1（n 为上一次的长度）而 HashMap 的初始长度为<br>16，之后每次扩充变为原来的两倍。另外在 Hashtable<br>源码注释中有这么一句话：</p>
<p>大致意思：Hashtable 是线程安全，推荐使用 HashMap 代替<br>Hashtable；如果需要线程安全高并发的话，推荐使用 ConcurrentHashMap 代替<br>Hashtable。</p>
<p>这个回答完了，面试官可能会继续问：HashMap<br>是线程不安全的，那么在需要线程安全的情况下还要考虑性能，有什么解决方式？</p>
<p>这里最好的选择就是 ConcurrentHashMap 了，但面试官肯定会叫你继续说一下</p>
<p>ConcurrentHashMap 数据结构以及底层原理等。</p>
<h2 id="40、HashMap-中的-key-我们可以使用任何类作为-key-吗？"><a href="#40、HashMap-中的-key-我们可以使用任何类作为-key-吗？" class="headerlink" title="40、HashMap 中的 key 我们可以使用任何类作为 key 吗？"></a>40、HashMap 中的 key 我们可以使用任何类作为 key 吗？</h2><p>平时可能大家使用的最多的就是使用 String 作为 HashMap 的<br>key，但是现在我们想使用某个自定义类作为 HashMap 的<br>key，那就需要注意以下几点：</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 如果类重写了 equals<br>方法，它也应该重写 hashCode 方法。<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 类的所有实例需要遵循与 equals 和<br>hashCode 相关的规则。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 如果一个类没有使用 equals，你不应该在<br>hashCode 中使用它。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 咱们自定义 key<br>类的最佳实践是使之为不可变的，这样，hashCode<br>值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode 和<br>equals 在未来不会改变，这样就会解决与可变相关的问题了。</p>
</blockquote>
<h2 id="41、HashMap-的长度为什么是-2-的-N-次方呢？"><a href="#41、HashMap-的长度为什么是-2-的-N-次方呢？" class="headerlink" title="41、HashMap 的长度为什么是 2 的 N 次方呢？"></a>41、HashMap 的长度为什么是 2 的 N 次方呢？</h2><p>为了能让 HashMap 存数据和取数据的效率高，尽可能地减少 hash<br>值的碰撞，也就是说尽量把数据能均匀的分配，每个链表或者红黑树长度尽量相等。</p>
<p><img src="/assets/image9.png">{width&#x3D;”0.1771576990376203in”<br>height&#x3D;”0.19799978127734033in”}我们首先可能会想到 下面是回答的重点哟：</p>
<p>取模的操作来实现。</p>
<blockquote>
<p>取余（%）操作中如果除数是 2<br>的幂次，则等价于与其除数减一的与（&amp;）操作（也就是说</p>
<p><img src="/assets/image9.png">{width&#x3D;”0.1771576990376203in”<br>height&#x3D;”0.19799978127734033in”}<img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image9.png">{width&#x3D;”0.1771576990376203in”<br>height&#x3D;”0.19799978127734033in”}的前提是 length 是 2 的 n<br>次方）。并且，采用二进</p>
<p>制位操作</p>
<p>，相对于</p>
<p>能够提高运算效率。</p>
</blockquote>
<p>这就是为什么 HashMap 的长度需要 2 的 N 次方了。</p>
<h2 id="42、HashMap-与-ConcurrentHashMap-的异同"><a href="#42、HashMap-与-ConcurrentHashMap-的异同" class="headerlink" title="42、HashMap 与 ConcurrentHashMap 的异同"></a>42、HashMap 与 ConcurrentHashMap 的异同</h2><ol>
<li><p>都是 key-value 形式的存储数据；</p>
</li>
<li><p>HashMap 是线程不安全的，ConcurrentHashMap 是 JUC 下的线程安全的；</p>
</li>
<li><p>HashMap 底层数据结构是数组 + 链表（JDK 1.8 之前）。JDK 1.8<br>之后是数组 + 链表 + 红黑 树。当链表中元素个数达到 8<br>的时候，链表的查询速度不如红黑树快，链表会转为红黑树，红黑树查询速度快；</p>
</li>
<li><p>HashMap 初始数组大小为 16（默认），当出现扩容的时候，以 0.75 *<br>数组大小的方式进行扩容；</p>
</li>
<li><p>ConcurrentHashMap 在 JDK 1.8 之前是采用分段锁来现实的 Segment +<br>HashEntry， Segment 数组大小默认是 16，2 的 n 次方；JDK 1.8<br>之后，采用 Node + CAS + Synchronized来保证并发安全进行实现。</p>
</li>
</ol>
<h2 id="43、红黑树有哪几个特征？"><a href="#43、红黑树有哪几个特征？" class="headerlink" title="43、红黑树有哪几个特征？"></a>43、红黑树有哪几个特征？</h2><p>紧接上个问题，面试官很有可能会问红黑树，下面把红黑树的几个特征列出来：</p>
<p><img src="/assets/image10.jpeg">{width&#x3D;”6.81082895888014in”<br>height&#x3D;”2.9204166666666667in”}</p>
<h2 id="44、说说你平时是怎么处理-Java-异常的"><a href="#44、说说你平时是怎么处理-Java-异常的" class="headerlink" title="44、说说你平时是怎么处理 Java 异常的"></a>44、说说你平时是怎么处理 Java 异常的</h2><p>try-catch-ﬁnally</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} try 块负责监控可能出现异常的代码</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} catch<br>块负责捕获可能出现的异常，并进行处理</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} ﬁnally<br>块负责清理各种资源，不管是否出现异常都会执行</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 其中 try 块是必须的，catch 和 ﬁnally<br>至少存在一个标准异常处理流程</p>
<p><img src="/assets/image11.jpeg">{width&#x3D;”6.807832458442695in”<br>height&#x3D;”2.9608333333333334in”}</p>
<p>抛出异常→捕获异常→捕获成功（当 catch<br>的异常类型与抛出的异常类型匹配时，捕获成功）</p>
<p>→异常被处理，程序继续运行 抛出异常→捕获异常→捕获失败（当 catch<br>的异常类型与抛出异常类型不匹配时，捕获失败）→异常未被处理，程序中断运行</p>
</blockquote>
<p>在开发过程中会使用到自定义异常，在通常情况下，程序很少会自己抛出异常，因为异常的类名通常也包含了该异常的有用信息，所以在选择抛出异常的时候，应该选择合适的异常类，从而可以明确地描述该异常情况，所以这时候往往都是自定义异常。</p>
<p>自定义异常通常是通过继承 java.lang.Exception 类，如果想自定义 Runtime<br>异常的话，可以继承</p>
<p>java.lang.RuntimeException<br>类，实现一个无参构造和一个带字符串参数的有参构造方法。</p>
<p>在业务代码里，可以针对性的使用自定义异常。比如说：该用户不具备某某权限、余额不足等。</p>
<h2 id="45、说说深拷贝和浅拷贝？"><a href="#45、说说深拷贝和浅拷贝？" class="headerlink" title="45、说说深拷贝和浅拷贝？"></a>45、说说深拷贝和浅拷贝？</h2><p>浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，</p>
<p>深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，</p>
<p>使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。最好是结合克隆已经原型模式联系在一起哈，记得复习的时候，把这几个联系起来的。</p>
<blockquote>
<p>欢迎关注微信公众号：Java后端技术全栈</p>
</blockquote>
<h1 id="JVM篇"><a href="#JVM篇" class="headerlink" title="JVM篇"></a>JVM篇</h1><h2 id="1、知识点汇总"><a href="#1、知识点汇总" class="headerlink" title="1、知识点汇总"></a>1、知识点汇总</h2><p>JVM是Java运行基础,面试时一定会遇到JVM的有关问题,内容相对集中,但对只是深度要求较高.</p>
<p><img src="/assets/image12.jpeg">{width&#x3D;”6.8207884951881015in”<br>height&#x3D;”5.431561679790026in”}</p>
<p>其中内存模型,类加载机制,GC是重点方面.性能调优部分更偏向应用,重点突出实践能力.编译器优化和执行模式部分偏向于理论基础,重点掌握知识点.</p>
<p>需了解 <strong>内存模型</strong>各部分作用,保存哪些数据.</p>
<p><strong>类加载</strong>双亲委派加载机制,常用加载器分别加载哪种类型的类.</p>
<p><strong>GC</strong>分代回收的思想和依据以及不同垃圾回收算法的回收思路和适合场景.</p>
<p><strong>性能调优</strong>常有JVM优化参数作用,参数调优的依据,常用的JVM分析工具能分析哪些问题以及使用方法.<strong>执行模式</strong>解释&#x2F;编译&#x2F;混合模式的优缺点,Java7提供的分层编译技术,JIT即时编译技术,OSR栈上替</p>
<p>换,C1&#x2F;C2编译器针对的场景,C2针对的是server模式,优化更激进.新技术方面Java10的graal编译器</p>
<p><strong>编译器优化j</strong>avac的编译过程,ast抽象语法树,编译器优化和运行器优化.</p>
<h2 id="2、知识点详解："><a href="#2、知识点详解：" class="headerlink" title="2、知识点详解："></a>2、知识点详解：</h2><h4 id="1、JVM内存模型："><a href="#1、JVM内存模型：" class="headerlink" title="1、JVM内存模型："></a>1、JVM内存模型：</h4><p>线程独占:栈,本地方法栈,程序计数器 线程共享:堆,方法区</p>
<h4 id="2、栈："><a href="#2、栈：" class="headerlink" title="2、栈："></a>2、栈：</h4><p>又称方法栈,线程私有的,线程执行方法是都会创建一个栈阵,用来存储局部变量表,操作栈,动态链接,方法出口等信息.调用方法时执行入栈,方法返回式执行出栈.</p>
<h4 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h4><p>与栈类似,也是用来保存执行方法的信息.执行Java方法是使用栈,执行Native方法时使用本地方法栈.<br><strong>4、程序计数器</strong></p>
<p>保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行</p>
<p>Native方法时,程序计数器为空. <strong>5、堆</strong></p>
<p>JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,当堆没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回收器进行垃圾的回收管理</p>
<h4 id="6、方法区："><a href="#6、方法区：" class="headerlink" title="6、方法区："></a>6、方法区：</h4><p>又称非堆区,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据.1.7的永久代和1.8的元空间都是方法区的一种实现</p>
<h4 id="7、JVM-内存可见性"><a href="#7、JVM-内存可见性" class="headerlink" title="7、JVM 内存可见性"></a>7、JVM 内存可见性</h4><p><img src="/assets/image13.png">{width&#x3D;”6.557606080489939in”<br>height&#x3D;”4.040624453193351in”}</p>
<p>JMM是定义程序中变量的访问规则,线程对于变量的操作只能在自己的工作内存中进行,而不能直接对主内存操作.由于指令重排序,读写的顺序会被打乱,因此JMM需要提供原子性,可见性,有序性保证.</p>
<p><img src="/assets/image14.jpeg">{width&#x3D;”6.432367672790901in”<br>height&#x3D;”1.1659372265966754in”}</p>
<h2 id="3、说说类加载与卸载"><a href="#3、说说类加载与卸载" class="headerlink" title="3、说说类加载与卸载"></a>3、说说类加载与卸载</h2><h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><p><img src="/assets/image15.jpeg">{width&#x3D;”6.59251312335958in”<br>height&#x3D;”1.8199989063867017in”}</p>
<blockquote>
<p>其中<strong>验证,准备,解析</strong>合称链接</p>
</blockquote>
<p><strong>加载</strong>通过类的完全限定名,查找此类字节码文件,利用字节码文件创建Class对象.<strong>验证</strong>确保Class文件符合当前虚拟机的要求,不会危害到虚拟机自身安全.</p>
<p><strong>准备</strong>进行内存分配,为static修饰的类变量分配内存,并设置初始值(0或null).不包含ﬁnal修饰的静态变量,因为ﬁnal变量在编译时分配.</p>
<p><strong>解析</strong>将常量池中的符号引用替换为直接引用的过程.直接引用为直接指向目标的指针或者相对偏移量等.</p>
<p><strong>初始化</strong>主要完成静态块执行以及静态变量的赋值.先初始化父类,再初始化当前类.只有对类主动使用时才会初始化.</p>
<p>触发条件包括,创建类的实例时,访问类的静态方法或静态变量的时候,使用Class.forName反射类的时候,或者某个子类初始化的时候.</p>
<p>Java自带的加载器加载的类,在虚拟机的生命周期中是不会被卸载的,只有用户自定义的加载器加载的类才可以被卸.</p>
<h4 id="1、加载机制-双亲委派模式"><a href="#1、加载机制-双亲委派模式" class="headerlink" title="1、加载机制-双亲委派模式"></a>1、加载机制-双亲委派模式</h4><p><img src="/assets/image16.jpeg">{width&#x3D;”6.775260279965004in”<br>height&#x3D;”4.701666666666667in”}</p>
<p>双亲委派模式,即加载器加载类时先把请求委托给自己的父类加载器执行,直到顶层的启动类加载器.父类加载器能够完成加载则成功返回,不能则子类加载器才自己尝试加载.*</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ol>
<li><p>避免类的重复加载</p>
</li>
<li><p>避免Java的核心API被篡改</p>
</li>
</ol>
<h4 id="2、分代回收"><a href="#2、分代回收" class="headerlink" title="2、分代回收"></a>2、分代回收</h4><p>分代回收基于两个事实:大部分对象很快就不使用了,还有一部分不会立即无用,但也不会持续很长时间.</p>
<p><img src="/assets/image17.jpeg">{width&#x3D;”6.73400699912511in”<br>height&#x3D;”1.4977077865266841in”}</p>
<p>年轻代-&gt;标记-复制 老年代-&gt;标记-清除</p>
<h4 id="3、回收算法"><a href="#3、回收算法" class="headerlink" title="3、回收算法"></a>3、回收算法</h4><blockquote>
<p><em>a</em>、<em>G1</em>算法</p>
</blockquote>
<p>1.9后默认的垃圾回收算法,特点保持高回收率的同时减少停顿.采用每次只清理一部分,而不是清理全部的增量式清理,以保证停顿时间不会过长</p>
<p>其取消了年轻代与老年代的物理划分,但仍属于分代收集器,算法将堆分为若干个逻辑区域(region),一部分用作年轻代,一部分用作老年代,还有用来存储巨型对象的分区.</p>
<p>同CMS相同,会遍历所有对象,标记引用情况,清除对象后会对区域进行复制移动,以整合碎片空间.年轻代回收:<br>并行复制采用复制算法,并行收集,会StopTheWorld.</p>
<p>老年代回收: 会对年轻代一并回收</p>
<p>初始标记完成堆root对象的标记,会StopTheWorld. 并发标记<br>GC线程和应用线程并发执行. 最终标记完成三色标记周期,会StopTheWorld.<br>复制&#x2F;清楚会优先对可回收空间加大的区域进行回收</p>
<blockquote>
<p><em>b</em>、<em>ZGC</em>算法</p>
</blockquote>
<p>前面提供的高效垃圾回收算法,针对大堆内存设计,可以处理TB级别的堆,可以做到10ms以下的回收停顿时间.</p>
<p><img src="/assets/image18.jpeg">{width&#x3D;”6.811371391076116in”<br>height&#x3D;”2.5972911198600177in”}</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 着色指针<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 读屏障</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 并发处理</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 基于region</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 内存压缩(整理)</p>
</blockquote>
<p>roots标记：标记root对象,会StopTheWorld.<br>并发标记：利用读屏障与应用线程一起运行标记,可能会发生StopTheWorld.<br>清除会清理标记为不可用的对象.<br>roots重定位：是对存活的对象进行移动,以腾出大块内存空间,减少碎片产生.重定位最开始会StopTheWorld,却决于重定位集与对象总活动集的比例.<br>并发重定位与并发标记类似.</p>
<h2 id="4、简述一下JVM的内存模型"><a href="#4、简述一下JVM的内存模型" class="headerlink" title="4、简述一下JVM的内存模型"></a>4、简述一下JVM的内存模型</h2><h4 id="JVM内存模型简介"><a href="#JVM内存模型简介" class="headerlink" title="JVM内存模型简介"></a>JVM内存模型简介</h4><p>JVM定义了不同运行时数据区，他们是用来执行应用程序的。某些区域随着JVM启动及销毁，另外一些区域的数据是线程性独立的，随着线程创建和销毁。jvm内存模型总体架构图如下：（摘自oracle<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">[官方网站]{.underline}</a>）</p>
<p><img src="/assets/image19.jpeg">{width&#x3D;”6.201832895888014in”<br>height&#x3D;”3.84625in”}</p>
<p>JVM在执行Java程序时，会把它管理的内存划分为若干个的区域，每个区域都有自己的用途和创建销毁时间。如下图所示，可以分为两大部分，线程私有区和共享区。下图是根据自己理解画的一个<br>JVM内存模型架构图：</p>
<blockquote>
<p><img src="/assets/image20.jpeg">{width&#x3D;”6.83609251968504in”<br>height&#x3D;”3.6849989063867015in”}</p>
<p>JVM内存分为线程私有区和线程共享区<strong>线程私有区</strong></p>
</blockquote>
<h4 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h4><p>当同时进行的线程数超过CPU数或其内核数时，就要通过时间片轮询分派CPU的时间资源，不免发生线程切换。这时，每个线程就需要一个属于自己的计数器来记录下一条要运行的指令。如果执行的是JAVA方法，计数器记录正在执行的java字节码地址，如果执行的是native方法，则计数器为<br>空。</p>
<h4 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h4><p>线程私有的，与线程在同一时间创建。管理JAVA方法执行的内存模型。每个方法执行时都会创建一个桢栈来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）。栈的大小可以是固定的，或者是动态扩展的。如果请求的栈深度大于最大可用深度，则抛出stackOverﬂowError；如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出<br>OutofMemoryError。<br>使用jclasslib工具可以查看class类文件的结构。下图为栈帧结构图：</p>
<blockquote>
<p><img src="/assets/image21.jpeg">{width&#x3D;”6.312498906386701in”<br>height&#x3D;”2.9479166666666665in”}</p>
</blockquote>
<h4 id="3、本地方法栈-1"><a href="#3、本地方法栈-1" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h4><p>与虚拟机栈作用相似。但它不是为Java方法服务的，而是本地方法（C语言）。由于规范对这块没有强制要求，不同虚拟机实现方法不同。</p>
<h4 id="线程共享区"><a href="#线程共享区" class="headerlink" title="线程共享区"></a>线程共享区</h4><blockquote>
<p><strong>1、方法区</strong></p>
</blockquote>
<p>线程共享的，用于存放被虚拟机加载的类的元数据信息，如常量、静态变量和即时编译器编译后的代码。若要分代，算是永久代（老年代），以前类大多”static”的，很少被卸载或收集，现回收废弃常量和无用的类。其中运行时常量池存放编译生成的各种常量。（如果hotspot虚拟机确定一个类的定义信息不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，而且装载该类的ClassLoader被回收）</p>
<h4 id="2、堆"><a href="#2、堆" class="headerlink" title="2、堆"></a>2、堆</h4><p>存放对象实例和数组，是垃圾回收的主要区域，分为新生代和老年代。刚创建的对象在新生代的<br>Eden区中，经过GC后进入新生代的S0区中，再经过GC进入新生代的S1区中，15次GC后仍存在就进入老年代。这是按照一种回收机制进行划分的，不是固定的。若堆的空间不够实例分配，则<br>OutOfMemoryError。</p>
<p><img src="/assets/image22.jpeg">{width&#x3D;”5.96875in”<br>height&#x3D;”1.9479166666666667in”}</p>
<h2 id="5、说说堆和栈的区别"><a href="#5、说说堆和栈的区别" class="headerlink" title="5、说说堆和栈的区别"></a>5、说说堆和栈的区别</h2><p>栈是运行时单位，代表着逻辑，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片；堆是存储单位，代表着数据，可被多个栈共享（包括成员中基本数据类型、引用和引用对象），所在区域不连续，会有碎片。</p>
<h4 id="1、功能不同"><a href="#1、功能不同" class="headerlink" title="1、功能不同"></a>1、功能不同</h4><p>栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p>
<h4 id="2、共享性不同"><a href="#2、共享性不同" class="headerlink" title="2、共享性不同"></a>2、共享性不同</h4><p>栈内存是线程私有的。 堆内存是所有线程共有的。</p>
<h4 id="3、异常错误不同"><a href="#3、异常错误不同" class="headerlink" title="3、异常错误不同"></a>3、异常错误不同</h4><p>如果栈内存或者堆内存不足都会抛出异常。<br>栈空间不足：java.lang.StackOverFlowError。<br>堆空间不足：java.lang.OutOfMemoryError。</p>
<h4 id="4、空间大小"><a href="#4、空间大小" class="headerlink" title="4、空间大小"></a>4、空间大小</h4><p>栈的空间大小远远小于堆的。</p>
<h2 id="6、-什么时候会触发FullGC"><a href="#6、-什么时候会触发FullGC" class="headerlink" title="6、 什么时候会触发FullGC"></a>6、 什么时候会触发FullGC</h2><p>除直接调用System.gc外，触发Full GC执行的情况有如下四种。 <strong>1.<br>旧生代空间不足</strong><br>旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full<br>GC后空间仍然不</p>
<p>足，则抛出如下错误： java.lang.OutOfMemoryError: Java heap space<br>为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor<br>GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<ol start="2">
<li><p><strong>Permanet Generation空间满</strong><br>PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet<br>Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full<br>GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信 息：<br>java.lang.OutOfMemoryError: PermGen space 为避免Perm Gen占满造成Full<br>GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p>
</li>
<li><p><strong>CMS GC时出现promotion failed和concurrent mode failure</strong><br>对于采用CMS进行旧生代GC的程序而言，尤其要注意GC日志中是否有promotion<br>failed和concurrent mode<br>failure两种状况，当这两种状况出现时可能会触发Full GC。<br>promotionfailed是在进行Minor GC时，survivor<br>space放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent<br>mode failure是在执行 CMS<br>GC的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。<br>应对措施为：增大<br>survivorspace、旧生代空间或调低触发并发GC的比率，但在JDK<br>5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可通过设置-<br>XX:CMSMaxAbortablePrecleanTime&#x3D;5（单位为ms）来避免。</p>
</li>
<li><p><strong>统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间</strong><br>这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor<br>GC时，做了一个判断，如果之前统计所得到的Minor<br>GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full<br>GC。 例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生<br>代，那么当下一次Minor<br>GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，</p>
</li>
</ol>
<p>则执行Full GC。 当新生代采用PSGC时，方式稍有不同，PS GC是在Minor<br>GC后也会检查，例如上面的例子中第一次Minor GC后，PS<br>GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。<br>除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun<br>JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过-<br>java- Dsun.rmi.dgc.client.gcInterval&#x3D;3600000来设置Full<br>GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</p>
<h2 id="7、什么是Java虚拟机？为什么Java被称作是”平台无关的编程语言”？"><a href="#7、什么是Java虚拟机？为什么Java被称作是”平台无关的编程语言”？" class="headerlink" title="7、什么是Java虚拟机？为什么Java被称作是”平台无关的编程语言”？"></a>7、什么是Java虚拟机？为什么Java被称作是”平台无关的编程语言”？</h2><p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。<br>Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<h2 id="8、Java内存结构"><a href="#8、Java内存结构" class="headerlink" title="8、Java内存结构"></a>8、Java内存结构</h2><blockquote>
<p><img src="/assets/image23.jpeg">{width&#x3D;”6.746849300087489in”<br>height&#x3D;”6.4375in”}</p>
</blockquote>
<p>方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 方法区（Method Area）,方法区（Method<br>Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 程序计数器（Program Counter<br>Register）,程序计数器（Program Counter<br>Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} JVM栈（JVM<br>Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine<br>Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack<br>Frame）用于存储局部变量表、操作栈、动态</p>
<p>链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 本地方法栈（Native Method<br>Stacks）,本地方法栈（Native Method<br>Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服</p>
<p>务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p>
</blockquote>
<h2 id="9、说说对象分配规则"><a href="#9、说说对象分配规则" class="headerlink" title="9、说说对象分配规则"></a>9、说说对象分配规则</h2><blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor<br>GC。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在</p>
<p>Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次<br>Minor GC那么对象会进入Survivor区，之后每经过一次Minor<br>GC那么对象的年龄加1，知道达到阀值对象进入老年区。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 空间分配担保。每次进行Minor<br>GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full<br>GC，如果小于检查 HandlePromotionFailure设置，如果true则只进行Monitor<br>GC,如果false则进行Full GC。</p>
</blockquote>
<h2 id="10、描述一下JVM加载class文件的原理机制？"><a href="#10、描述一下JVM加载class文件的原理机制？" class="headerlink" title="10、描述一下JVM加载class文件的原理机制？"></a>10、描述一下JVM加载class文件的原理机制？</h2><p>JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。<br>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，<br>JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的<br>Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。<br>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器</p>
<p>（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子</p>
<p>类）。从Java 2（JDK<br>1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了<br>Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</p>
<p><img src="/assets/image24.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</p>
</blockquote>
<h2 id="11、说说Java对象创建过程"><a href="#11、说说Java对象创建过程" class="headerlink" title="11、说说Java对象创建过程"></a>11、说说Java对象创建过程</h2><ol>
<li><p>JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类（类加载过程在后边讲）</p>
</li>
<li><p>为对象分配内存。一种办法”指针碰撞”、一种办法”空闲列表”，最终常用的办法”本地线程缓冲分配(TLAB)”</p>
</li>
<li><p>将除对象头外的对象内存空间初始化为0</p>
</li>
<li><p>对对象头进行必要设置</p>
</li>
</ol>
<h2 id="12、知道类的生命周期吗？"><a href="#12、知道类的生命周期吗？" class="headerlink" title="12、知道类的生命周期吗？"></a>12、知道类的生命周期吗？</h2><p>类的生命周期包括这几个部分，加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程,如下图；</p>
<p><img src="/assets/image25.jpeg">{width&#x3D;”6.346536526684164in”<br>height&#x3D;”1.9078116797900262in”}</p>
<blockquote>
<p><img src="/assets/image24.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</p>
<p><img src="/assets/image24.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>连接，连接又包含三块内容：验证、准备、初始化。<br>1）验证，文件格式、元数据、字节码、符号引用验证；<br>2）准备，为类的静态变量分配内存，并将其初始化为默认值；<br>3）解析，把类中的符号引用转换为直接引用</p>
<p><img src="/assets/image24.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>初始化，为类的静态变量赋予正确的初始值<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image24.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 使用，new出对象程序中使用</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image24.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 卸载，执行垃圾回收</p>
</blockquote>
<h2 id="13、简述Java的对象结构"><a href="#13、简述Java的对象结构" class="headerlink" title="13、简述Java的对象结构"></a>13、简述Java的对象结构</h2><p>Java对象由三个部分组成：对象头、实例数据、对齐填充。</p>
<p>对象头由两部分组成，第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32&#x2F;64<br>bit）。第二部分是指针类型，指向对象的类元数据类型</p>
<p>（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）</p>
<p>对齐填充：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）</p>
<h2 id="14、如何判断对象可以被回收？"><a href="#14、如何判断对象可以被回收？" class="headerlink" title="14、如何判断对象可以被回收？"></a>14、如何判断对象可以被回收？</h2><p>判断对象是否存活一般有两种方式：</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 可达性分析（Reachability<br>Analysis）：从GC<br>Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC<br>Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。</p>
</blockquote>
<h2 id="15、JVM的永久代中会发生垃圾回收么？"><a href="#15、JVM的永久代中会发生垃圾回收么？" class="headerlink" title="15、JVM的永久代中会发生垃圾回收么？"></a>15、JVM的永久代中会发生垃圾回收么？</h2><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full<br>GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full<br>GC是非常重要的原因。请参考下Java8：从永久代到元数据区<br>(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)</p>
<h2 id="16、你知道哪些垃圾收集算法"><a href="#16、你知道哪些垃圾收集算法" class="headerlink" title="16、你知道哪些垃圾收集算法"></a>16、你知道哪些垃圾收集算法</h2><p>GC最基础的算法有三种： 标记<br>-清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 标记<br>-清除算法，”标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为”标记”和”清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>复制算法，”复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>标记-压缩算法，标记过程仍然与”标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>分代收集算法，”分代收集”（Generational<br>Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
</blockquote>
<h2 id="17、调优命令有哪些？"><a href="#17、调优命令有哪些？" class="headerlink" title="17、调优命令有哪些？"></a>17、调优命令有哪些？</h2><p>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} jps，JVM Process Status<br>Tool,显示指定系统内所有的HotSpot虚拟机进程。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} jstat，JVM statistics<br>Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} jmap，JVM Memory Map命令用于生成heap<br>dump文件</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} jhat，JVM Heap Analysis<br>Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>jstack，用于生成java虚拟机当前时刻的线程快照。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} jinfo，JVM Conﬁguration info<br>这个命令作用是实时查看和调整虚拟机运行参数。</p>
</blockquote>
<h2 id="18、常见调优工具有哪些"><a href="#18、常见调优工具有哪些" class="headerlink" title="18、常见调优工具有哪些"></a>18、常见调优工具有哪些</h2><p>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory<br>Analyzer Tool)、GChisto。</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} jconsole，Java Monitoring and<br>Management<br>Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} MAT，Memory Analyzer<br>Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的</p>
<p>Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} GChisto，一款专业分析gc日志的工具</p>
</blockquote>
<h2 id="19、Minor-GC与Full-GC分别在什么时候发生？"><a href="#19、Minor-GC与Full-GC分别在什么时候发生？" class="headerlink" title="19、Minor GC与Full GC分别在什么时候发生？"></a>19、Minor GC与Full GC分别在什么时候发生？</h2><p>新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC</p>
<h2 id="20、你知道哪些JVM性能调优参数？（简单版回答）"><a href="#20、你知道哪些JVM性能调优参数？（简单版回答）" class="headerlink" title="20、你知道哪些JVM性能调优参数？（简单版回答）"></a>20、你知道哪些JVM性能调优参数？（简单版回答）</h2><blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 设定堆内存大小</p>
</blockquote>
<p>-Xmx：堆内存最大限制。</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 设定新生代大小。<br>新生代不宜太小，否则会有大量对象涌入老年代</p>
</blockquote>
<p>-XX:NewSize：新生代大小</p>
<p>-XX:NewRatio 新生代和老生代占比</p>
<p>-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 设定垃圾回收器 年轻代用<br>-XX:+UseParNewGC 年老代用-XX:+UseConcMarkSweepGC</p>
</blockquote>
<h2 id="21、-对象一定分配在堆中吗？有没有了解逃逸分析技术？"><a href="#21、-对象一定分配在堆中吗？有没有了解逃逸分析技术？" class="headerlink" title="21、 对象一定分配在堆中吗？有没有了解逃逸分析技术？"></a>21、 对象一定分配在堆中吗？有没有了解逃逸分析技术？</h2><blockquote>
<p><strong>「对象一定分配在堆中吗？」</strong><br>不一定的，JVM通过<strong>「逃逸分析」</strong>，那些逃不出方法的对象会在栈上分配。</p>
</blockquote>
<h4 id="width-”5-210520559930009e-2in”-height-”5-210520559930009e-2in”-「什么是逃逸分析？」"><a href="#width-”5-210520559930009e-2in”-height-”5-210520559930009e-2in”-「什么是逃逸分析？」" class="headerlink" title="{width&#x3D;”5.210520559930009e-2in” height&#x3D;”5.210520559930009e-2in”} 「什么是逃逸分析？」"></a><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image24.png">{width&#x3D;”5.210520559930009e-2in” height&#x3D;”5.210520559930009e-2in”} 「什么是逃逸分析？」</h4><p>逃逸分析(Escape Analysis)，是一种可以有效减少Java<br>程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java<br>Hotspot编译器能够分析出一个新的对象的引用的使用范围，从而决定是否要将这个对象分配到堆上。</p>
<p><strong>逃逸分析</strong>是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。通俗点讲，如果一个对象的指针被多个方法或者线程引用时，那么我们就称这个对象的指针发生了逃逸。</p>
<h4 id="「逃逸分析的好处」"><a href="#「逃逸分析的好处」" class="headerlink" title="「逃逸分析的好处」"></a>「逃逸分析的好处」</h4><blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image24.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>栈上分配，可以降低垃圾收集器运行的频率。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image24.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>同步消除，如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image24.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>标量替换，把对象分解成一个个基本类型，并且内存分配不再是分配在堆上，而是分配在栈<br>上。这样的好处有，一、减少内存使用，因为不用生成对象头。二、程序内存回收效率高，并且GC频率也会减少。</p>
</blockquote>
<h2 id="22、虚拟机为什么使用元空间替换了永久代？"><a href="#22、虚拟机为什么使用元空间替换了永久代？" class="headerlink" title="22、虚拟机为什么使用元空间替换了永久代？"></a>22、虚拟机为什么使用元空间替换了永久代？</h2><blockquote>
<p><strong>「什么是元空间？什么是永久代？为什么用元空间代替永久代？」</strong><br>我们先回顾一下<strong>「方法区」</strong>吧,看看虚拟机运行时数据内存图，如下:</p>
<p><img src="/assets/image26.jpeg">{width&#x3D;”6.7923654855643045in”<br>height&#x3D;”5.2425in”}</p>
<p>方法区和堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p>
</blockquote>
<h4 id="「什么是永久代？它和方法区有什么关系呢？」"><a href="#「什么是永久代？它和方法区有什么关系呢？」" class="headerlink" title="「什么是永久代？它和方法区有什么关系呢？」"></a>「什么是永久代？它和方法区有什么关系呢？」</h4><blockquote>
<p>如果在HotSpot虚拟机上开发、部署，很多程序员都把方法区称作永久代。可以说方法区是规范，永久代是Hotspot针对该规范进行的实现。在Java7及以前的版本，方法区都是永久代实现的。</p>
</blockquote>
<h4 id="「什么是元空间？它和方法区有什么关系呢？」"><a href="#「什么是元空间？它和方法区有什么关系呢？」" class="headerlink" title="「什么是元空间？它和方法区有什么关系呢？」"></a>「什么是元空间？它和方法区有什么关系呢？」</h4><blockquote>
<p>对于Java8，HotSpots取消了永久代，取而代之的是元空间(Metaspace)。换句话说，就是方法区还是在的，只是实现变了，从永久代变为元空间了。</p>
</blockquote>
<h4 id="「为什么使用元空间替换了永久代？」"><a href="#「为什么使用元空间替换了永久代？」" class="headerlink" title="「为什么使用元空间替换了永久代？」"></a>「为什么使用元空间替换了永久代？」</h4><blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>永久代的方法区，和堆使用的物理内存是连续的。</p>
<p><img src="/assets/image27.png">{width&#x3D;”6.85047353455818in”<br>height&#x3D;”3.12625in”}</p>
</blockquote>
<p><strong>「永久代」</strong>是通过以下这两个参数配置大小的~<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} -XX:PremSize：设置永久代的初始大小</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} -XX:MaxPermSize:<br>设置永久代的最大值，默认是64M</p>
<p>对于<strong>「永久代」</strong>，如果动态生成很多class的话，就很可能出现<strong>「java.lang.OutOfMemoryError:<br>PermGen<br>space错误」</strong>，因为永久代空间配置有限嘛。最典型的场景是，在web开发比较多jsp页面的时候。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>JDK8之后，方法区存在于元空间(Metaspace)。物理内存不再与堆连续，而是直接存在于本地内存中，理论上机器<strong>「内存有多大，元空间就有多大」</strong>。</p>
<p><img src="/assets/image28.png">{width&#x3D;”6.749759405074366in”<br>height&#x3D;”5.10625in”}</p>
</blockquote>
<p>可以通过以下的参数来设置元空间的大小：</p>
<blockquote>
<p><img src="/assets/image29.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</p>
<p><img src="/assets/image29.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p>
<p><img src="/assets/image29.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</p>
<p><img src="/assets/image29.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p>
</blockquote>
<h4 id="「所以，为什么使用元空间替换永久代？」"><a href="#「所以，为什么使用元空间替换永久代？」" class="headerlink" title="「所以，为什么使用元空间替换永久代？」"></a>「所以，为什么使用元空间替换永久代？」</h4><blockquote>
<p>表面上看是为了避免OOM异常。因为通常使用PermSize和MaxPermSize设置永久代的大小就决定了永久代的上限，但是不是总能知道应该设置为多大合适,<br>如果使用默认值很容易遇到<br>OOM错误。当使用元空间时，可以加载多少类的元数据就不再由MaxPermSize控制,<br>而由系统的实际可用空间来控制啦。</p>
</blockquote>
<h2 id="23、什么是Stop-The-World-什么是OopMap？什么是安全点？"><a href="#23、什么是Stop-The-World-什么是OopMap？什么是安全点？" class="headerlink" title="23、什么是Stop The World ? 什么是OopMap？什么是安全点？"></a>23、什么是Stop The World ? 什么是OopMap？什么是安全点？</h2><p>进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为<strong>「Stop<br>The World」</strong>。也简称为STW。</p>
<p>在HotSpot中，有个数据结构（映射表）称为<strong>「OopMap」</strong>。一旦类加载动作完成的时候，<br>HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。在即时编译过程中，也会在<strong>「特定的位置」</strong>生成<br>OopMap，记录下栈上和寄存器里哪些位置是引用。</p>
<p>这些特定的位置主要在：</p>
<ol>
<li><p>循环的末尾（非 counted 循环）</p>
</li>
<li><p>方法临返回前 &#x2F; 调用方法的call指令后</p>
</li>
<li><p>可能抛异常的位置</p>
</li>
</ol>
<blockquote>
<p>这些位置就叫作<strong>「安全点(safepoint)。」</strong><br>用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集，而是必须是执行到安全点才能够暂停。</p>
</blockquote>
<h2 id="24、说一下JVM-的主要组成部分及其作用？"><a href="#24、说一下JVM-的主要组成部分及其作用？" class="headerlink" title="24、说一下JVM 的主要组成部分及其作用？"></a>24、说一下JVM 的主要组成部分及其作用？</h2><p><img src="/assets/image30.png">{width&#x3D;”6.749759405074366in” height&#x3D;”4.03125in”}</p>
<p>JVM包含两个子系统和两个组件，分别为<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} Class loader(类装载子系统)</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} Execution engine(执行引擎子系统)；</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} Runtime data area(运行时数据区组件)</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} Native Interface(本地接口组件)。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} <strong>「Class loader(类装载)：」</strong><br>根据给定的全限定名类名(如：java.lang.Object)来装载class文件到运行时数据区的方法区中。</p>
<p><img src="/assets/image31.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} <strong>「Execution<br>engine（执行引擎）」</strong>：执行class的指令。</p>
<p><img src="/assets/image31.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} <strong>「Native Interface(本地接口)：」</strong><br>与native lib交互，是其它编程语言交互的接口。<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image31.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} <strong>「Runtime data<br>area(运行时数据区域)」</strong>：即我们常说的JVM的内存。</p>
<p>首先通过编译器把 Java源代码转换成字节码，Class<br>loader(类装载)再把字节码加载到内存</p>
<p>中，将其放在运行时数据区的方法区内，而字节码文件只是 JVM<br>的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution<br>Engine），将字节码翻译成底层系统指令，再交由 CPU<br>去执行，而这个过程中需要调用其他语言的本地库接口（Native<br>Interface）来实现整个程序的功能。</p>
</blockquote>
<h2 id="25、什么是指针碰撞？"><a href="#25、什么是指针碰撞？" class="headerlink" title="25、什么是指针碰撞？"></a>25、什么是指针碰撞？</h2><p>一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。如果Java堆中内存是绝对规整的，所有被使用过的的内存都被放到一边，空闲的内存放到另外一边，中间放着一个指针作为分界点的指示器，所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例，这种分配方式就是<br>指针碰撞。</p>
<p><img src="/assets/image32.png">{width&#x3D;”6.847318460192476in”<br>height&#x3D;”2.1286450131233594in”}</p>
<h2 id="26，什么是空闲列表？"><a href="#26，什么是空闲列表？" class="headerlink" title="26，什么是空闲列表？"></a>26，什么是空闲列表？</h2><p>如果Java堆内存中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，不可以进行指针碰撞啦，虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。</p>
<h2 id="27，什么是TLAB？"><a href="#27，什么是TLAB？" class="headerlink" title="27，什么是TLAB？"></a>27，什么是TLAB？</h2><p><img src="/assets/image33.png">{width&#x3D;”0.10421041119860018in”<br>height&#x3D;”0.1979844706911636in”}可以把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在Java堆中预先分配一小块内存,这就是TLAB（Thread<br>Local Allocation Buﬀer，本地线程分配缓存） 。虚拟机通过 -</p>
<blockquote>
<p>设定它的。</p>
</blockquote>
<h2 id="28、对象头具体都包含哪些内容？"><a href="#28、对象头具体都包含哪些内容？" class="headerlink" title="28、对象头具体都包含哪些内容？"></a>28、对象头具体都包含哪些内容？</h2><p>在我们常用的Hotspot虚拟机中，对象在内存中布局实际包含3个部分：</p>
<ol>
<li><p>对象头</p>
</li>
<li><p>实例数据</p>
</li>
<li><p>对齐填充</p>
</li>
</ol>
<p>而对象头包含两部分内容，Mark<br>Word中的内容会随着锁标志位而发生变化，所以只说存储结构就好了。</p>
<ol>
<li><p>对象自身运行时所需的数据，也被称为Mark<br>Word，也就是用于轻量级锁和偏向锁的关键点。具体的内容包含对象的hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记、偏向锁线程ID、偏向锁时间戳。</p>
</li>
<li><p>存储类型指针，也就是指向类的元数据的指针，通过这个指针才能确定对象是属于哪个类的实例。</p>
</li>
</ol>
<p>如果是数组的话，则还包含了数组的长度。</p>
<p><img src="/assets/image34.jpeg">{width&#x3D;”6.75135498687664in” height&#x3D;”3.05in”}</p>
<h2 id="29、你知道哪些JVM调优参数？"><a href="#29、你知道哪些JVM调优参数？" class="headerlink" title="29、你知道哪些JVM调优参数？"></a>29、你知道哪些JVM调优参数？</h2><h4 id="「堆栈内存相关」"><a href="#「堆栈内存相关」" class="headerlink" title="「堆栈内存相关」"></a>「堆栈内存相关」</h4><blockquote>
<p><img src="/assets/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} -Xms 设置初始堆的大小</p>
<p><img src="/assets/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} -Xmx 设置最大堆的大小</p>
<p><img src="/assets/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} -Xmn<br>设置年轻代大小，相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值</p>
<p><img src="/assets/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} -Xss 每个线程的堆栈大小</p>
<p><img src="/assets/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} -XX:NewSize 设置年轻代大小(for<br>1.3&#x2F;1.4)</p>
<p><img src="/assets/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} -XX:MaxNewSize 年轻代最大值(for<br>1.3&#x2F;1.4)</p>
<p><img src="/assets/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} -XX:NewRatio<br>年轻代与年老代的比值(除去持久代)<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} -XX:SurvivorRatio<br>Eden区与Survivor区的的比值</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} -XX:PretenureSizeThreshold<br>当创建的对象超过指定大小时，直接把对象分配在老年代。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>-XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代</p>
</blockquote>
<h4 id="「垃圾收集器相关」"><a href="#「垃圾收集器相关」" class="headerlink" title="「垃圾收集器相关」"></a>「垃圾收集器相关」</h4><blockquote>
<p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>-XX:ParallelGCThreads&#x3D;20：配置并行收集器的线程数</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} -XX:CMSFullGCsBeforeCompaction&#x3D;5<br>由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生”碎片”，使得运行效率降低。此值设置运行5次GC以后对内存空间进行压缩、整理。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p>
</blockquote>
<h4 id="「辅助信息相关」"><a href="#「辅助信息相关」" class="headerlink" title="「辅助信息相关」"></a>「辅助信息相关」</h4><blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} -XX:+PrintGCDetails 打印GC详细信息</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>-XX:+HeapDumpOnOutOfMemoryError让JVM在发生内存溢出的时候自动生成内存快照,</p>
<p>排查问题用</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>-XX:+DisableExplicitGC禁止系统System.gc()，防止手动误触发FGC造成问题.<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image35.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} -XX:+PrintTLAB 查看TLAB空间的使用情况</p>
</blockquote>
<h2 id="30、说一下-JVM-有哪些垃圾回收器？"><a href="#30、说一下-JVM-有哪些垃圾回收器？" class="headerlink" title="30、说一下 JVM 有哪些垃圾回收器？"></a>30、说一下 JVM 有哪些垃圾回收器？</h2><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下图展示了<br>7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel<br>Scavenge，回收老年代的收集器包括Serial Old、Parallel<br>Old、CMS，还有用于回收整个Java堆的<br>G1收集器。不同收集器之间的连线表示它们可以搭配使用。</p>
<p><img src="/assets/image36.jpeg">{width&#x3D;”5.552083333333333in” height&#x3D;”3.5625in”}</p>
<blockquote>
<p>Serial收集器（复制算法):<br>新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</p>
<p>ParNew收集器 (复制算法):<br>新生代收并行集器，实际上是Serial收集器的多线程版本，在多核</p>
<p>CPU环境下有着比Serial更好的表现；</p>
<p>Parallel Scavenge收集器 (复制算法):<br>新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 &#x3D;<br>用户线程时间&#x2F;(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</p>
<p>Serial Old收集器 (标记-整理算法):<br>老年代单线程收集器，Serial收集器的老年代版本；</p>
<p>Parallel Old收集器 (标记-整理算法)：<br>老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</p>
<p>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）：<br>老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</p>
<p>G1(Garbage First)收集器 (标记-整理算法)：<br>Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于”标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</p>
<p>（Z Garbage<br>Collector）是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。它是基于动态Region内存布局，（暂时）不设年龄分代，使用了读屏障、染色指针和内</p>
<p>存多重映射等技术来实现可并发的标记-整理算法的收集器。在<br>新加入，还在实验阶</p>
<p>段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。<strong>优点</strong>：低停顿，高吞吐</p>
<p>量， 收集过程中额外耗费的内存小。<strong>缺点</strong>：浮动垃圾</p>
<p>目前使用的非常少，真正普及还是需要写时间的。</p>
<p><strong>新生代收集器</strong>：Serial、 、</p>
</blockquote>
<h4 id="width-”0-26052602799650043in”-height-”0-19799978127734033in”-老年代收集器：整堆收集器："><a href="#width-”0-26052602799650043in”-height-”0-19799978127734033in”-老年代收集器：整堆收集器：" class="headerlink" title="{width&#x3D;”0.26052602799650043in” height&#x3D;”0.19799978127734033in”}老年代收集器：整堆收集器："></a><img src="/assets/image4.png">{width&#x3D;”0.26052602799650043in” height&#x3D;”0.19799978127734033in”}老年代收集器：整堆收集器：</h4><blockquote>
<p>，</p>
</blockquote>
<p>、Serial Old、Parallel Old</p>
<blockquote>
<p>(因为不涉年代不在图中)。</p>
</blockquote>
<h2 id="31、如何选择垃圾收集器？"><a href="#31、如何选择垃圾收集器？" class="headerlink" title="31、如何选择垃圾收集器？"></a>31、如何选择垃圾收集器？</h2><ol>
<li>如果你的堆大小不是很大（比如</li>
</ol>
<p>），选择串行收集器一般是效率最高的。</p>
<blockquote>
<p>参数： 。</p>
</blockquote>
<ol start="2">
<li>如果你的应用运行在单核的机器上，或者你的虚拟机核数只有单核，选择串行收集器依然是合适的，这时候启用一些并行收集器没有任何收益。</li>
</ol>
<blockquote>
<p>参数： 。</p>
</blockquote>
<ol start="3">
<li>如果你的应用是”吞吐量”优先的，并且对较长时间的停顿没有什么特别的要求。选择并行收集器是比较好的。</li>
</ol>
<blockquote>
<p>参数： 。</p>
</blockquote>
<ol start="4">
<li><img src="/assets/image37.png">{width&#x3D;”0.26052602799650043in”<br>height&#x3D;”0.19799978127734033in”}如果你的应用对响应时间要求较高，想要较少的停顿。甚至<br>1 秒的停顿都会引起大量的请求失</li>
</ol>
<blockquote>
<p>败，那么选择</p>
<p>、</p>
<p>、</p>
<p>都是合理的。虽然这些收集器的 GC 停顿通常都比较短，但它</p>
<p>需要一些额外的资源去处理这些工作，通常吞吐量会低一些。</p>
<p>参数：</p>
<p>、</p>
<p>、等。</p>
</blockquote>
<p><img src="/assets/image37.png">{width&#x3D;”0.26052602799650043in”<br>height&#x3D;”0.19799978127734033in”}从上面这些出发点来看，我们平常的 Web<br>服务器，都是对响应性要求非常高的。选择性其实就集</p>
<p>中在</p>
<blockquote>
<p>、</p>
<p>、</p>
</blockquote>
<p>上。而对于某些定时任务，使用并行收集器，是一个比较好的选择。</p>
<h2 id="32、-什么是类加载器？"><a href="#32、-什么是类加载器？" class="headerlink" title="32、 什么是类加载器？"></a>32、 什么是类加载器？</h2><p>类加载器是一个用来加载类文件的类。Java 源代码通过 javac 编译器编译成类<br>文件。然后 JVM 来执行类文件中的字节码来执行程序。类加载器负责加载文件<br>系统、网络或其他来源的类文件。</p>
<h2 id="33、什么是-tomcat-类加载机制？"><a href="#33、什么是-tomcat-类加载机制？" class="headerlink" title="33、什么是 tomcat 类加载机制？"></a>33、什么是 tomcat 类加载机制？</h2><p>在 tomcat 中类的加载稍有不同，如下图：</p>
<p><img src="/assets/image38.jpeg">{width&#x3D;”5.708333333333333in”<br>height&#x3D;”4.34375in”}</p>
<blockquote>
<p>当 tomcat启动时，会创建几种类加载器： <strong>Bootstrap 引导类加载器</strong> 加载<br>JVM启动所需的类，以及</p>
<p>标准扩展类（位于 下） <strong>System 系统类加载器</strong> 加载 tomcat<br>启动的类，比如</p>
</blockquote>
<p>bootstrap.jar，通常在 catalina.bat 或者 中指定。位于 下。</p>
<p><img src="/assets/image39.jpeg">{width&#x3D;”5.562498906386701in”<br>height&#x3D;”1.6145833333333333in”}</p>
<h4 id="Common-通用类加载器"><a href="#Common-通用类加载器" class="headerlink" title="Common 通用类加载器"></a>Common 通用类加载器</h4><p>欢迎关注微信公众号：Java后端技术全栈</p>
<h1 id="多线程-并发篇"><a href="#多线程-并发篇" class="headerlink" title="多线程&amp;并发篇"></a>多线程&amp;并发篇</h1><h2 id="1、说说Java中实现多线程有几种方法"><a href="#1、说说Java中实现多线程有几种方法" class="headerlink" title="1、说说Java中实现多线程有几种方法"></a>1、说说Java中实现多线程有几种方法</h2><p>创建线程的常用三种方式：</p>
<ol>
<li><p>继承Thread类</p>
</li>
<li><p>实现Runnable接口</p>
</li>
<li><p>实现Callable接口（ ）</p>
</li>
<li><p>线程池方式创建</p>
</li>
</ol>
<p>通过继承Thread类或者实现Runnable接口、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法返回值，可以声明抛出异常而已。因此将实现Runnable接口和实现Callable接口归为一种方式。这种方式与继承Thread方式之间的主要差别如下。</p>
<h4 id="采用实现Runnable、Callable接口的方式创建线程的优缺点"><a href="#采用实现Runnable、Callable接口的方式创建线程的优缺点" class="headerlink" title="采用实现Runnable、Callable接口的方式创建线程的优缺点"></a>采用实现Runnable、Callable接口的方式创建线程的优缺点</h4><p><strong>优点</strong>：线程类只是实现了Runnable或者Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将</p>
<p>CPU、代码和数据分开，形成清晰的模型，较好的体现了面向对象的思想。</p>
<blockquote>
<p><strong>缺点</strong>：编程稍微复杂一些，如果需要访问当前线程，则必须使用<br>方法<strong>采用继承Thread类的方式创建线程的优缺点</strong></p>
</blockquote>
<p><strong>优点</strong>：编写简单，如果需要访问当前线程，则无需使用</p>
<p>this即可获取当前线程</p>
<p>方法，直接使用</p>
<p><strong>缺点</strong>：因为线程类已经继承了Thread类，Java语言是单继承的，所以就不能再继承其他父类了。</p>
<h2 id="2、如何停止一个正在运行的线程"><a href="#2、如何停止一个正在运行的线程" class="headerlink" title="2、如何停止一个正在运行的线程"></a>2、如何停止一个正在运行的线程</h2><p>1、使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</p>
<p>2、使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。</p>
<p>3、使用interrupt方法中断线程。</p>
<h2 id="3、notify-和notifyAll-有什么区别？"><a href="#3、notify-和notifyAll-有什么区别？" class="headerlink" title="3、notify()和notifyAll()有什么区别？"></a>3、notify()和notifyAll()有什么区别？</h2><p>notify可能会导致死锁，而notifyAll则不会</p>
<p>任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行synchronized<br>中的代码</p>
<p>使用notifyall,可以唤醒<br>所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</p>
<p>wait()<br>应配合while循环使用，不应使用if，务必在wait()调用前后都检查条件，如果不满足，必须调用notify()唤醒另外的线程来处理，自己继续wait()直至条件满足再往下执行。</p>
<p>notify()<br>是对notifyAll()的一个优化，但它有很精确的应用场景，并且要求正确使用。不然可能导致死锁。正确的场景应该是<br>WaitSet中等待的是相同的条件，唤醒任一个都能正确处理接下来的事<br>项，如果唤醒的线程无法正确处理，务必确保继续notify()下一个线程，并且自身需要重新回到<br>WaitSet中.</p>
<h2 id="4、sleep-和wait-有什么区别？"><a href="#4、sleep-和wait-有什么区别？" class="headerlink" title="4、sleep()和wait() 有什么区别？"></a>4、sleep()和wait() 有什么区别？</h2><p>对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。</p>
<p>sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。</p>
<p>当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用</p>
<p>notify()方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。</p>
<h2 id="5、volatile-是什么-可以保证有序性吗"><a href="#5、volatile-是什么-可以保证有序性吗" class="headerlink" title="5、volatile 是什么?可以保证有序性吗?"></a>5、volatile 是什么?可以保证有序性吗?</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ol>
<li><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。</p>
</li>
<li><p>禁止进行指令重排序。 volatile 不是原子性操作 什么叫保证部分有序性?</p>
</li>
</ol>
<p>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>由于ﬂag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句<br>2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>使用volatile 一般用于 状态标记量 和 单例模式的双检锁。</p>
<h2 id="6、Thread-类中的start-和-run-方法有什么区别？"><a href="#6、Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="6、Thread 类中的start() 和 run() 方法有什么区别？"></a>6、Thread 类中的start() 和 run() 方法有什么区别？</h2><p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>
<h2 id="7、为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#7、为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="7、为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>7、为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h2><p>明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p>
<h2 id="8、为什么wait和notify方法要在同步块中调用？"><a href="#8、为什么wait和notify方法要在同步块中调用？" class="headerlink" title="8、为什么wait和notify方法要在同步块中调用？"></a>8、为什么wait和notify方法要在同步块中调用？</h2><ol>
<li><p>只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。</p>
</li>
<li><p>如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。</p>
</li>
<li><p>还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
</li>
</ol>
<p>wait()方法强制当前线程释放对象锁。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法。</p>
<p>在调用对象的notify()和notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。</p>
<p>调用wait()方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用<br>notify()或notifyAll()方法的原因通常是，调用线程希望告诉其他等待中的线程:&quot;特殊状态已经被设置&quot;。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。</p>
<h2 id="9、Java中interrupted-和-isInterruptedd方法的区别？"><a href="#9、Java中interrupted-和-isInterruptedd方法的区别？" class="headerlink" title="9、Java中interrupted 和 isInterruptedd方法的区别？"></a>9、Java中interrupted 和 isInterruptedd方法的区别？</h2><p>interrupted() 和<br>isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出<br>InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p>
<h2 id="10、Java中synchronized-和-ReentrantLock-有什么不同？"><a href="#10、Java中synchronized-和-ReentrantLock-有什么不同？" class="headerlink" title="10、Java中synchronized 和 ReentrantLock 有什么不同？"></a>10、Java中synchronized 和 ReentrantLock 有什么不同？</h2><p>相似点：</p>
<p>这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等<br>待，而进行线程阻塞和唤醒的代价是比较高的.</p>
<p>区别：</p>
<p>这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK<br>1.5之后提供的API层面的互斥锁，需要lock()和<br>unlock()方法配合try&#x2F;ﬁnally语句块来完成。</p>
<p>Synchronized进过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。</p>
<p>由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，</p>
<p>ReentrantLock类提供了一些高级功能，主要有以下3项：</p>
<ol>
<li><p>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于<br>Synchronized来说可以避免出现死锁的情况。</p>
</li>
<li><p>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</p>
</li>
<li><p>锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。</p>
</li>
</ol>
<h2 id="11、有三个线程T1-T2-T3-如何保证顺序执行？"><a href="#11、有三个线程T1-T2-T3-如何保证顺序执行？" class="headerlink" title="11、有三个线程T1,T2,T3,如何保证顺序执行？"></a>11、有三个线程T1,T2,T3,如何保证顺序执行？</h2><p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。</p>
<p>实际上先启动三个线程中哪一个都行，<br>因为在每个线程的run方法中用join方法限定了三个线程的执行顺序。</p>
<blockquote>
<p>public class JoinTest2 {</p>
<p>&#x2F;&#x2F;<br>1.现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行<br>public static void main(String[] args) {</p>
<p>final Thread t1 &#x3D; new Thread(new Runnable() {</p>
<p>@Override</p>
<p>public void run() { System.out.println(&quot;t1&quot;);</p>
<p>}</p>
<p>});</p>
<p>final Thread t2 &#x3D; new Thread(new Runnable() {</p>
<p>@Override</p>
<p>public void run() { try {</p>
<p>&#x2F;&#x2F; 引用t1线程，等待t1线程执行完</p>
<p>t1.join();</p>
<p>} catch (InterruptedException e) { e.printStackTrace();</p>
<p>}</p>
<p>});</p>
<p>}</p>
<p>System.out.println(&quot;t2&quot;);</p>
<p>Thread t3 &#x3D; new Thread(new Runnable() {</p>
<p>@Override</p>
<p>public void run() { try {</p>
<p>&#x2F;&#x2F; 引用t2线程，等待t2线程执行完</p>
<p>t2.join();</p>
<p>} catch (InterruptedException e) { e.printStackTrace();</p>
<p>}</p>
<p>System.out.println(&quot;t3&quot;);</p>
<p>}</p>
</blockquote>
<h2 id="12、SynchronizedMap和ConcurrentHashMap有什么区别？"><a href="#12、SynchronizedMap和ConcurrentHashMap有什么区别？" class="headerlink" title="12、SynchronizedMap和ConcurrentHashMap有什么区别？"></a>12、SynchronizedMap和ConcurrentHashMap有什么区别？</h2><p>SynchronizedMap()和Hashtable一样，实现上在调用map所有方法时，都对整个map进行同步。而ConcurrentHashMap的实现却更加精细，它对map中的所有桶加了锁。所以，只要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。</p>
<p>所以，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。同时，同步操作精确控制到桶，这样，即使在遍历map时，如果其他线程试图对map进行数据修改，也不会抛出ConcurrentModiﬁcationException。</p>
<h2 id="13、什么是线程安全"><a href="#13、什么是线程安全" class="headerlink" title="13、什么是线程安全"></a>13、什么是线程安全</h2><p>线程安全就是说多线程访问同一段代码，不会产生不确定的结果。</p>
<blockquote>
<p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：<strong>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的</strong>。</p>
</blockquote>
<p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p>
<ol>
<li>不可变</li>
</ol>
<p>像String、Integer、Long这些，都是ﬁnal类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p>
<ol start="2">
<li>绝对线程安全</li>
</ol>
<p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的<br>类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p>
<ol start="3">
<li>相对线程安全</li>
</ol>
<p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个<br>Vector，99%的情况下都会出现ConcurrentModiﬁcationException，也就是<strong>fail-fast机制</strong>。</p>
<ol start="4">
<li>线程非安全</li>
</ol>
<p>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p>
<h2 id="14、Thread类中的yield方法有什么作用？"><a href="#14、Thread类中的yield方法有什么作用？" class="headerlink" title="14、Thread类中的yield方法有什么作用？"></a>14、Thread类中的yield方法有什么作用？</h2><p>Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p>
<h2 id="15、Java线程池中submit-和-execute-方法有什么区别？"><a href="#15、Java线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="15、Java线程池中submit() 和 execute()方法有什么区别？"></a>15、Java线程池中submit() 和 execute()方法有什么区别？</h2><p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中,而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了<br>Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p>
<h2 id="16、说一说自己对于-synchronized-关键字的了解"><a href="#16、说一说自己对于-synchronized-关键字的了解" class="headerlink" title="16、说一说自己对于 synchronized 关键字的了解"></a>16、说一说自己对于 synchronized 关键字的了解</h2><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。<br>另外，在 Java 早期版本中，<br>synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的<br>Mutex Lock 来实现的，Java<br>的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核</p>
<p>态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的<br>synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM<br>层面对synchronized 较大优化，所以现在的 synchronized<br>锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<h2 id="17、说说自己是怎么使用-synchronized-关键字？"><a href="#17、说说自己是怎么使用-synchronized-关键字？" class="headerlink" title="17、说说自己是怎么使用 synchronized 关键字？"></a>17、说说自己是怎么使用 synchronized 关键字？</h2><p><strong>修饰实例方法</strong>:<br>作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁<br><strong>修饰静态方法</strong>:也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（<br>static<br>表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态<br>synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized<br>方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized<br>方法占用的锁是当前类的锁，而访问非静态 synchronized<br>方法占用的锁是当前实例对象锁。 修饰代码块</strong>:<br>指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。<br><strong>总结</strong>： synchronized 关键字加到 static 静态方法和<br>synchronized(class)代码块上都是是给 Class<br>类上锁。synchronized关键字加到实例方法上是给对象实例上锁。尽量不要使用<br>synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p>
<h2 id="18、什么是线程安全？Vector是一个线程安全类吗？"><a href="#18、什么是线程安全？Vector是一个线程安全类吗？" class="headerlink" title="18、什么是线程安全？Vector是一个线程安全类吗？"></a>18、什么是线程安全？Vector是一个线程安全类吗？</h2><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量<br>的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失</p>
<p>误。很显然你可以将集合类分 成两组，线程安全和非线程安全的。Vector<br>是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p>
<h2 id="19、-volatile关键字的作用？"><a href="#19、-volatile关键字的作用？" class="headerlink" title="19、 volatile关键字的作用？"></a>19、 volatile关键字的作用？</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 禁止进行指令重排序。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>volatile仅能实现变量的修改可见性，并不能保证原子性；synchronized则可以保证变量的修改可见性和原子性。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p>
</blockquote>
<p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p>
<h2 id="20、常用的线程池有哪些？"><a href="#20、常用的线程池有哪些？" class="headerlink" title="20、常用的线程池有哪些？"></a>20、常用的线程池有哪些？</h2><blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
</blockquote>
<h2 id="21、简述一下你对线程池的理解"><a href="#21、简述一下你对线程池的理解" class="headerlink" title="21、简述一下你对线程池的理解"></a>21、简述一下你对线程池的理解</h2><p>（如果问到了这样的问题，可以展开的说一下线程池如何用、线程池的好处、线程池的启动策略）合理利用线程池能够带来三个好处。</p>
<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
<p>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p>
<p>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
<h2 id="22、Java程序是如何执行的"><a href="#22、Java程序是如何执行的" class="headerlink" title="22、Java程序是如何执行的"></a>22、Java程序是如何执行的</h2><p>我们日常的工作中都使用开发工具（IntelliJ IDEA 或 Eclipse<br>等）可以很方便的调试程序，或者是通过打包工具把项目打包成 jar 包或者 war<br>包，放入 Tomcat 等 Web 容器中就可以正常运行了，但你有没有想过 Java<br>程序内部是如何执行的？其实不论是在开发工具中运行还是在 Tomcat 中运行，<br>Java 程序的执行流程基本都是相同的，它的执行流程如下：</p>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 先把 Java 代码编译成字节码，也就是把<br>.java 类型的文件编译成 .class 类型的文件。这个过程的大致执行流程：Java<br>源代码 -&gt; 词法分析器 -&gt; 语法分析器 -&gt; 语义分析器 -&gt; 字符码生成器<br>-&gt;最终生成字节码，其中任何一个节点执行失败就会造成编译失败；</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} 把 class 文件放置到 Java<br>虚拟机，这个虚拟机通常指的是 Oracle 官方自带的 Hotspot JVM；<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} Java 虚拟机使用类加载器（Class<br>Loader）装载 class 文件；</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>类加载完成之后，会进行字节码效验，字节码效验通过之后 JVM<br>解释器会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是解释执行的，JVM<br>对此做了优化，比如，以 Hotspot 虚拟机来说，它本身提供了 JIT（Just In<br>Time）也就是我们通常所说的动态编译器，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了编译执行。Java<br>程序执行流程图如下：</p>
<p><img src="/assets/image40.jpeg">{width&#x3D;”6.62749343832021in”<br>height&#x3D;”5.045833333333333in”}</p>
</blockquote>
<h2 id="23、锁的优化机制了解吗？"><a href="#23、锁的优化机制了解吗？" class="headerlink" title="23、锁的优化机制了解吗？"></a>23、锁的优化机制了解吗？</h2><p>从JDK1.6版本之后，synchronized本身也在不断优化锁的机制，有些情况下他并不会是一个很重量级的锁了。优化机制包括自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁。</p>
<blockquote>
<p>锁的状态从低到高依次为<strong>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</strong>，升级的过程就是从低到高，降级在一定条件也是有可能发生的。</p>
</blockquote>
<p><strong>自旋锁</strong>：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，用户态和内核态的来回上下文切换严重影响性能。自旋的概念就是让线程执行一个忙循环，可以理解为就是啥也不干，防止从用户态转入内核态，自旋锁可以通过设置-XX:+UseSpining来开启，自旋的默认次数是10次，可以使用-XX:PreBlockSpin设置。</p>
<p><strong>自适应锁</strong>：自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，而是由前一次在同一个锁上的自旋时间和锁的持有者状态来决定。</p>
<p><strong>锁消除</strong>：锁消除指的是JVM检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进行锁消除。</p>
<p><strong>锁粗化</strong>：锁粗化指的是有很多操作都是对同一个对象进行加锁，就会把锁的同步范围扩展到整个操作序列之外。</p>
<p><strong>偏向锁</strong>：当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，之后这个线程再次进入同步块时都不需要CAS来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线<br>程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。可以用过设置-XX:+UseBiasedLocking开启偏向锁。</p>
<p><strong>轻量级锁</strong>：JVM的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，JVM将会使用<br>CAS方式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败，当前线程就尝试自旋来获得锁。</p>
<p>整个锁升级的过程非常复杂，我尽力去除一些无用的环节，简单来描述整个升级的机制。</p>
<p>简单点说，偏向锁就是通过对象头的偏向线程ID来对比，甚至都不需要CAS了，而轻量级锁主要就是通过CAS修改对象头锁记录和自旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。</p>
<p><img src="/assets/image41.jpeg">{width&#x3D;”6.750134514435696in”<br>height&#x3D;”4.33125in”}</p>
<h2 id="24、说说进程和线程的区别？"><a href="#24、说说进程和线程的区别？" class="headerlink" title="24、说说进程和线程的区别？"></a>24、说说进程和线程的区别？</h2><ol>
<li><p>进程是一个”执行中的程序”，是系统进行资源分配和调度的一个独立单位。</p>
</li>
<li><p>线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以通信和同步等操作线程比进程更加容易）</p>
</li>
<li><p>线程上下文的切换比进程上下文切换要快很多。</p>
</li>
</ol>
<blockquote>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>（1）进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image3.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>（2）线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</p>
</blockquote>
<h2 id="25，产生死锁的四个必要条件？"><a href="#25，产生死锁的四个必要条件？" class="headerlink" title="25，产生死锁的四个必要条件？"></a>25，产生死锁的四个必要条件？</h2><ol>
<li><p>互斥条件：一个资源每次只能被一个线程使用</p>
</li>
<li><p>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放</p>
</li>
<li><p>不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺</p>
</li>
<li><p>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系</p>
</li>
</ol>
<h2 id="26、如何避免死锁？"><a href="#26、如何避免死锁？" class="headerlink" title="26、如何避免死锁？"></a>26、如何避免死锁？</h2><p>指定获取锁的顺序，举例如下：</p>
<ol>
<li><p>比如某个线程只有获得A锁和B锁才能对某资源进行操作，在多线程条件下，如何避免死锁？</p>
</li>
<li><p>获得锁的顺序是一定的，比如规定，只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可以避免死锁！！！</p>
</li>
</ol>
<h2 id="27，线程池核心线程数怎么设置呢？"><a href="#27，线程池核心线程数怎么设置呢？" class="headerlink" title="27，线程池核心线程数怎么设置呢？"></a>27，线程池核心线程数怎么设置呢？</h2><p>分为CPU密集型和IO密集型</p>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比<br>CPU<br>核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU<br>就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU<br>的空闲时间。</p>
<h4 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型"></a>IO密集型</h4><p>这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O<br>的时间段内不会占用 CPU 来处理，这时就可以将 CPU<br>交出给其它线程使用。因此在 I&#x2F;O<br>密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 ：<br>核心线程数&#x3D;CPU核心数量*2。</p>
<h2 id="28，Java线程池中队列常用类型有哪些？"><a href="#28，Java线程池中队列常用类型有哪些？" class="headerlink" title="28，Java线程池中队列常用类型有哪些？"></a>28，Java线程池中队列常用类型有哪些？</h2><blockquote>
<p>是一个基于数组结构的<strong>有界阻塞队列</strong>，此队列按 FIFO（先进先出）原则</p>
<p>对元素进行排序。</p>
<p>素，吞吐量通常要高于</p>
</blockquote>
<p>一个基于链表结构的<strong>阻塞队列</strong>，此队列按FIFO （先进先出） 排序元</p>
<blockquote>
<p>。</p>
</blockquote>
<h4 id="最小二叉堆实现"><a href="#最小二叉堆实现" class="headerlink" title="最小二叉堆实现"></a>最小二叉堆实现</h4><blockquote>
<p>一个不存储元素的<strong>阻塞队列</strong>。</p>
<p>一个具有优先级的<strong>无限阻塞队列</strong>。</p>
<p>也是<strong>基于</strong></p>
<p><img src="/assets/image42.png">{width&#x3D;”6.25262467191601e-2in”<br>height&#x3D;”6.25262467191601e-2in”}<br>只有当其指定的延迟时间到了，才能够从队列中获取到该元素。是一个没有大小限制的队列，</p>
<p><img src="/assets/image42.png">{width&#x3D;”6.25262467191601e-2in”<br>height&#x3D;”6.25262467191601e-2in”}<br>因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p>
</blockquote>
<p>这里能说出前三种也就差不多了，如果能说全那是最好。</p>
<h2 id="29，线程安全需要保证几个基本特征？"><a href="#29，线程安全需要保证几个基本特征？" class="headerlink" title="29，线程安全需要保证几个基本特征？"></a>29，线程安全需要保证几个基本特征？</h2><blockquote>
<p><img src="/assets/image43.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br><strong>原子性</strong>，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</p>
<p><img src="/assets/image43.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br><strong>可见性</strong>，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile<br>就是负责保证可见性的。</p>
<p><img src="/assets/image43.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br><strong>有序性</strong>，是保证线程内串行语义，避免指令重排等。</p>
</blockquote>
<h2 id="30，说一下线程之间是如何通信的？"><a href="#30，说一下线程之间是如何通信的？" class="headerlink" title="30，说一下线程之间是如何通信的？"></a>30，说一下线程之间是如何通信的？</h2><p>线程之间的通信有两种方式：共享内存和消息传递。<strong>共享内存</strong></p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。</p>
<p>例如上图线程 A 与 线程 B<br>之间如果要通信的话，那么就必须经历下面两个步骤：</p>
<ol>
<li><p>线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去。</p>
</li>
<li><p>线程 B 到主内存中去读取线程 A 之前更新过的共享变量。<strong>消息传递</strong></p>
</li>
</ol>
<p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行</p>
<p>通信。在 Java 中典型的消息传递方式，就是</p>
<h2 id="31、CAS的原理呢？"><a href="#31、CAS的原理呢？" class="headerlink" title="31、CAS的原理呢？"></a>31、CAS的原理呢？</h2><blockquote>
<p>和</p>
</blockquote>
<p>，或者 。</p>
<p>CAS叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：</p>
<ol>
<li><p>变量内存地址，V表示</p>
</li>
<li><p>旧的预期值，A表示</p>
</li>
<li><p>准备设置的新值，B表示</p>
</li>
</ol>
<p>当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。</p>
<h2 id="32、CAS有什么缺点吗？"><a href="#32、CAS有什么缺点吗？" class="headerlink" title="32、CAS有什么缺点吗？"></a>32、CAS有什么缺点吗？</h2><p>CAS的缺点主要有3点：</p>
<p><strong>ABA问题</strong>：ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是<br>A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是<br>ABA的问题大部分场景下都不影响并发的最终效果。</p>
<p>Java中有AtomicStampedReference来解决这个问题，他加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。</p>
<blockquote>
<p><strong>循环时间长开销大</strong>：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。</p>
</blockquote>
<p><strong>只能保证一个共享变量的原子操作</strong>：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现。</p>
<h2 id="33、引用类型有哪些？有什么区别？"><a href="#33、引用类型有哪些？有什么区别？" class="headerlink" title="33、引用类型有哪些？有什么区别？"></a>33、引用类型有哪些？有什么区别？</h2><p>引用类型主要分为强软弱虚四种：</p>
<ol>
<li><p>强引用指的就是代码中普遍存在的赋值方式，比如A a &#x3D; new<br>A()这种。强引用关联的对象，永远不会被GC回收。</p>
</li>
<li><p>软引用可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。系统在发生内存溢出前会对这类引用的对象进行回收。</p>
</li>
<li><p>弱引用可以用WeakReference来描述，他的强度比软引用更低一点，弱引用的对象下一次GC的时候一定会被回收，而不管内存是否足够。</p>
</li>
<li><p>虚引用也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和<br>ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。</p>
</li>
</ol>
<h2 id="34、说说ThreadLocal原理？"><a href="#34、说说ThreadLocal原理？" class="headerlink" title="34、说说ThreadLocal原理？"></a>34、说说ThreadLocal原理？</h2><p>hreadLocal可以理解为线程本地变量，他会在每个线程都创建一个副本，那么在线程之间访问内部副本变量就行了，做到了线程之间互相隔离，相比于synchronized的做法是用空间来换时间。</p>
<p>ThreadLocal有一个静态内部类ThreadLocalMap，ThreadLocalMap又包含了一个Entry数组，<br>Entry本身是一个弱引用，他的key是指向ThreadLocal的弱引用，Entry具备了保存key<br>value键值对的能力。</p>
<p>弱引用的目的是为了防止内存泄露，如果是强引用那么ThreadLocal对象除非线程结束否则始终无法被回收，弱引用则会在下一次GC的时候被回收。</p>
<p>但是这样还是会存在内存泄露的问题，假如key和ThreadLocal对象被回收之后，entry中就存在key为null，但是value有值的entry对象，但是永远没办法被访问到，同样除非线程结束运行。</p>
<p>但是只要ThreadLocal使用恰当，在使用完之后调用remove方法删除Entry对象，实际上是不会出现这个问题的。</p>
<blockquote>
<p><img src="/assets/image44.jpeg">{width&#x3D;”6.847856517935258in”<br>height&#x3D;”2.789478346456693in”}</p>
</blockquote>
<h2 id="35、线程池原理知道吗？以及核心参数"><a href="#35、线程池原理知道吗？以及核心参数" class="headerlink" title="35、线程池原理知道吗？以及核心参数"></a>35、线程池原理知道吗？以及核心参数</h2><p>首先线程池有几个核心的参数概念：</p>
<ol>
<li><p>最大线程数maximumPoolSize</p>
</li>
<li><p>核心线程数corePoolSize</p>
</li>
<li><p>活跃时间keepAliveTime</p>
</li>
<li><p>阻塞队列workQueue</p>
</li>
<li><p>拒绝策略RejectedExecutionHandler</p>
</li>
</ol>
<p>当提交一个新任务到线程池时，具体的执行流程如下：</p>
<ol>
<li><p>当我们提交任务，线程池会根据corePoolSize大小创建若干任务数量线程执行任务</p>
</li>
<li><p>当任务的数量超过corePoolSize数量，后续的任务将会进入阻塞队列阻塞排队</p>
</li>
<li><p>当阻塞队列也满了之后，那么将会继续创建(maximumPoolSize-corePoolSize)个数量的线程来执行任务，如果任务处理完成，maximumPoolSize-corePoolSize额外创建的线程等待<br>keepAliveTime之后被自动销毁</p>
</li>
<li><p>如果达到maximumPoolSize，阻塞队列还是满的状态，那么将根据不同的拒绝策略对应处理</p>
</li>
</ol>
<p><img src="/assets/image45.jpeg">{width&#x3D;”6.761923665791776in”<br>height&#x3D;”2.80625in”}</p>
<h2 id="36、-线程池的拒绝策略有哪些？"><a href="#36、-线程池的拒绝策略有哪些？" class="headerlink" title="36、 线程池的拒绝策略有哪些？"></a>36、 线程池的拒绝策略有哪些？</h2><p>主要有4种拒绝策略：</p>
<ol>
<li><p>AbortPolicy：直接丢弃任务，抛出异常，这是默认策略</p>
</li>
<li><p>CallerRunsPolicy：只用调用者所在的线程来处理任务</p>
</li>
<li><p>DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务</p>
</li>
<li><p>DiscardPolicy：直接丢弃任务，也不抛出异常</p>
</li>
</ol>
<h2 id="37、说说你对JMM内存模型的理解？为什么需要JMM？"><a href="#37、说说你对JMM内存模型的理解？为什么需要JMM？" class="headerlink" title="37、说说你对JMM内存模型的理解？为什么需要JMM？"></a>37、说说你对JMM内存模型的理解？为什么需要JMM？</h2><p>随着CPU和内存的发展速度差异的问题，导致CPU的速度远快于内存，所以现在的CPU加入了高速缓存，高速缓存一般可以分为L1、L2、L3三级缓存。基于上面的例子我们知道了这导致了缓存一致性的问题，所以加入了缓存一致性协议，同时导致了内存可见性的问题，而编译器和CPU的重排序导致了原子性和有序性的问题，JMM内存模型正是对多线程操作下的一系列规范约束，因为不可能让陈雇员的代码去兼容所有的CPU，通过JMM我们才屏蔽了不同硬件和操作系统内存的访问差异，这样保证了Java程序在不同的平台下达到一致的内存访问效果，同时也是保证在高效并发的时候程序能够正确执行。</p>
<p><img src="/assets/image46.png">{width&#x3D;”6.787579833770779in” height&#x3D;”4.875in”}</p>
<p><strong>原子性</strong>：Java内存模型通过read、load、assign、use、store、write来保证原子性操作，此外还有</p>
<p>lock和unlock，直接对应着synchronized关键字的monitorenter和monitorexit字节码指令。</p>
<p><strong>可见性</strong>：可见性的问题在上面的回答已经说过，Java保证可见性可以认为通过volatile、</p>
<p>synchronized、ﬁnal来实现。</p>
<p><strong>有序性</strong>：由于处理器和编译器的重排序导致的有序性问题，Java通过volatile、synchronized来保证。</p>
<h4 id="happen-before规则"><a href="#happen-before规则" class="headerlink" title="happen-before规则"></a>happen-before规则</h4><p>虽然指令重排提高了并发的性能，但是Java虚拟机会对指令重排做出一些规则限制，并不能让所有的指令都随意的改变执行位置，主要有以下几点：</p>
<ol>
<li><p>单线程每个操作，happen-before于该线程中任意后续操作</p>
</li>
<li><p>volatile写happen-before与后续对这个变量的读</p>
</li>
<li><p>synchronized解锁happen-before后续对这个锁的加锁</p>
</li>
<li><p>ﬁnal变量的写happen-before于ﬁnal域对象的读，happen-before后续对ﬁnal变量的读</p>
</li>
<li><p>传递性规则，A先于B，B先于C，那么A一定先于C发生<strong>说了半天，到底工作内存和主内存是什么？</strong></p>
</li>
</ol>
<p>主内存可以认为就是物理内存，Java内存模型中实际就是虚拟机内存的一部分。而工作内存就是</p>
<p>CPU缓存，他有可能是寄存器也有可能是L1\L2\L3缓存，都是有可能的。</p>
<h2 id="38、多线程有什么用？"><a href="#38、多线程有什么用？" class="headerlink" title="38、多线程有什么用？"></a>38、多线程有什么用？</h2><p>一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓&quot;知其然知其所以然&quot;，&quot;会用&quot;只是&quot;知其然&quot;，&quot;为什么用&quot;才是&quot;知其所以然&quot;，只有达到&quot;知其然知其所以然&quot;的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：</p>
<ol>
<li>发挥多核CPU的优势</li>
</ol>
<blockquote>
<p>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至<br>16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。<strong>单核CPU上所谓的&quot;多线程&quot;那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程&quot;同时&quot;运行罢了</strong>。多核CPU上的多线程才是真正的多线<br>程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用<br>CPU的目的。</p>
</blockquote>
<ol start="2">
<li>防止阻塞</li>
</ol>
<p>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止</p>
<p>运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p>
<ol start="3">
<li>便于建模</li>
</ol>
<p>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务<br>D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p>
<h2 id="39、说说CyclicBarrier和CountDownLatch的区别？"><a href="#39、说说CyclicBarrier和CountDownLatch的区别？" class="headerlink" title="39、说说CyclicBarrier和CountDownLatch的区别？"></a>39、说说CyclicBarrier和CountDownLatch的区别？</h2><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p>
<ol>
<li><p>CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p>
</li>
<li><p>CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p>
</li>
<li><p>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p>
</li>
</ol>
<h2 id="40、什么是AQS？"><a href="#40、什么是AQS？" class="headerlink" title="40、什么是AQS？"></a>40、什么是AQS？</h2><p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，</p>
<p>ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队</p>
<p>列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p>
<p>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p>
<h2 id="41、了解Semaphore吗？"><a href="#41、了解Semaphore吗？" class="headerlink" title="41、了解Semaphore吗？"></a>41、了解Semaphore吗？</h2><p>emaphore就是一个信号量，它的作用是<strong>限制某段代码块的并发数</strong>。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n&#x3D;1，相当于变成了一个synchronized了。</p>
<h2 id="42、什么是Callable和Future"><a href="#42、什么是Callable和Future" class="headerlink" title="42、什么是Callable和Future?"></a>42、什么是Callable和Future?</h2><p>Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被<br>Future拿到，也就是说，Future可以拿到异步执行任务的返回值。可以认为是带有回调的<br>Runnable。</p>
<p>Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，<br>Future用于获取结果。</p>
<h2 id="43、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#43、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="43、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"></a>43、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p>
<p>这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>JDK7提供了7个阻塞队列。分别是：</p>
<blockquote>
<p><img src="/assets/image43.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} ArrayBlockingQueue<br>：一个由数组结构组成的有界阻塞队列。</p>
<p><img src="/assets/image43.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} LinkedBlockingQueue<br>：一个由链表结构组成的有界阻塞队列。<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image43.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”} PriorityBlockingQueue<br>：一个支持优先级排序的无界阻塞队列。<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image43.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image43.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>SynchronousQueue：一个不存储元素的阻塞队列。</p>
<p><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image43.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br><img src="/../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E5%85%AB%E8%82%A1%E7%9B%B8%E5%85%B3/media/image43.png">{width&#x3D;”5.210520559930009e-2in”<br>height&#x3D;”5.210520559930009e-2in”}<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>
</blockquote>
<p>Java<br>5之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait<br>,notify,notifyAll,sychronized这些关键字。而在java<br>5之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p>
<p>BlockingQueue接口是Queue的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中放入元素，取出元<br>素，它可以很好的控制线程之间的通信。</p>
<p>阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。</p>
<h2 id="44、什么是多线程中的上下文切换？"><a href="#44、什么是多线程中的上下文切换？" class="headerlink" title="44、什么是多线程中的上下文切换？"></a>44、什么是多线程中的上下文切换？</h2><p>在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。</p>
<p>在程序中，上下文切换过程中的”页码”信息是保存在进程控制块（PCB）中的。PCB还经常被称作”切换桢”（switchframe）。”页码”信息会一直保存到CPU的内存中，直到他们被再次使用。</p>
<p>上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p>
<h2 id="45、什么是Daemon线程？它有什么意义？"><a href="#45、什么是Daemon线程？它有什么意义？" class="headerlink" title="45、什么是Daemon线程？它有什么意义？"></a>45、什么是Daemon线程？它有什么意义？</h2><p>所谓后台(daemon)线程，也叫守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。</p>
<p>因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，<br>只要有任何非后台线程还在运行，程序就不会终止。</p>
<p>必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。注意：后台进程在不执行</p>
<p>ﬁnally子句的情况下就会终止其run()方法。</p>
<p>比如：JVM的垃圾回收线程就是Daemon线程，Finalizer也是守护线程。</p>
<h2 id="46、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#46、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="46、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>46、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h2><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</p>
<p>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p>
<p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</p>
<p>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。</p>
<p>在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<h4 id="乐观锁的实现方式："><a href="#乐观锁的实现方式：" class="headerlink" title="乐观锁的实现方式："></a>乐观锁的实现方式：</h4><p>1、使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</p>
<p>2、java中的Compare and Swap即CAS<br>，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。<br>CAS 操作中包含三个操作数 ——<br>需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。</p>
<h4 id="CAS缺点："><a href="#CAS缺点：" class="headerlink" title="CAS缺点："></a>CAS缺点：</h4><ol>
<li><p><strong>ABA问题：</strong>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出<br>A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行<br>CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决<br>ABA问题。</p>
</li>
<li><p><strong>循环时间长开销大：</strong>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p>
</li>
<li><p><strong>只能保证一个共享变量的原子操作：</strong>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p>
</li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">SuQingdong</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://crystal1999.github.io/2024/04/14/Java%E5%85%AB%E8%82%A1%E6%96%87/">https://crystal1999.github.io/2024/04/14/Java%E5%85%AB%E8%82%A1%E6%96%87/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">SuQingdong</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%85%AB%E8%82%A1/">
                                    <span class="chip bg-color">八股</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/myalipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/myWechat.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2024/04/14/Java%E5%85%AB%E8%82%A1%E6%96%87/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="Java八股文">
                        
                        <span class="card-title">Java八股文</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            八股文系列之Java。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-04-14
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0/" class="post-category">
                                    八股笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%85%AB%E8%82%A1/">
                        <span class="chip bg-color">八股</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/01/09/Pandas/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="Pandas">
                        
                        <span class="card-title">Pandas</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Pandas的基本概念、基本操作、绘图简介、API介绍等。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-01-09
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-category">
                                    学习笔记
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Pandas/">
                        <span class="chip bg-color">Pandas</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('50')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 小苏的碎碎念<br />'
            + '文章作者: SuQingdong<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('1'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">SuQingdong</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:1561823697@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1561823697" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1561823697" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
